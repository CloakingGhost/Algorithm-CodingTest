
# Spring

1. Spring Framework (Spring VS SpringBoot)
	- Spring
		- Java 기반의 애플리케이션 개발을 위한 오픈소스 프레임워크
		- 사용하는 이유 
		  : 웹 사이트나 웹 서비스를 만들 때 필요한 기능들을 미리 구현하여, 개발자가 비즈니스 로직에만 집중할 수 있게 함
	- SpringBoot
		- Tomcat과 같은 WAS가 내장되어 있어, 복잡한 설정 없이 Spring을 더 쉽게 사용할 수 있게 해주는 도구
		- SpringBoot가 없다면?
		  : 직접 WAS를 만들어 줘야함
2. MVC
   Spring FrameWork에서 제공하는 웹 모듈로, **Model-View-Controller** 디자인 패턴을 기반으로 웹 애플리케이션을 구축함
	- Model
		- 애플리케이션의 데이터와 비즈니스 로직을 담당한다.
		- Service & Repostiory가 해당
	- View
		- 사용자에게 보여지는 화면을 담당함
		- Rest API를 사용할 경우, JSON 형태의 데이터가 view
	- Controller
		- 사용자의 요청을 받아서 Moddel과 View를 연결하는 역할
		- Controller가 해당
3. 3계층 아키택처 : 3가지 형태로 서비스를 분리함
	- Controller (Presentation Layer)
		- 클라이언트와의 상호작용을 담당함
		- 클라이언트로부터 요청을 받아 처리하고, 응답을 반환한다.
	- Service (Business Layer)
		- 비즈니스 로직을 구현함 (+ 유효성 검사)
		- Controller와 Repository를 연결해줌
	- Repository (Data Access Layer) 
		- 데이터베이스와의 상호작용을 통해 데이터에 대한 CRUD를 실행함
		- CRUD : Create(생성), Read(조회), Update(수정), Delete(삭제)
4. DI (Dependency Injection) : 의존성 주입
	- 3계층 아키텍처에서 Controller는 Service를, Service는 Repository를 필요로 한다. 곧 하나의 클래스가 또 다른 클래스를 필요로 하는 것을 **의존성을 주입한다**고 함.
	- IoC의 구현체
	- 주로 생성자를 활용해 의존성을 주입한다.
	- 장점
		- - 객체 간의 결합도를 낮춤 (생성자를 통해 넣으면 mySQL이든 오라클이든 상관없어짐)
		- 테스트가 용이해짐 (내가 임시로 만든 repository로 테스트 가능. controller는 호출하는 역할만 해서, mock이어도 실행 가능)
		- 코드의 재사용성이 높아짐
5. IoC (Inversion of Control) : 제어의 역전
	- 객체를 생성하고 관리하는 주체가 개발자가 아닌 Spring과 같은 프레임워크가 담당하는 것
	- IoC가 필요한 이유?
		- 어떤 객체가 특정 구현체에 의존하고 있다면, 해당 구현체를 바꾸기만 하면 되므로 유연성이 높아진다.
6. Bean
   : 자바 객체 (= 클래스 / 더 자세하게는 클래스로 구현된 인스턴스) 
	- 스프링 빈을 모아둔 스프링 컨테이너에서 관리한다.
	- Bean으로 등록해야 하는 이유는?
		- Bean으로 등록되면, 스프링 컨테이너에서 싱글톤 패턴에 따라 각 클래스 별로 하나의 인스턴스를 자동으로 생성한다. 이 후 필요할 때 다른 객체에 의존성 주입을 통해 자동으로 주입된다.


# DataBase

1. Index
	- 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
	  (책의 목차 같은 역할)
	- 특정 열(컬럼)에 대한 빠른 조회를 가능하게 하기 때문에 자주 조회되는 컬럼에 인덱스를 생성하는 것이 좋음
2. Unique
	- 해당 컬럼에 중복된 값을 허용하지 않는 제약 조건
	- EX. 이메일 주소나 전화번호처럼 고유해야 하는 데이터에 설정
3. SQL (Structured Query Language)
	- 데이터베이스를 관리하고 데이터를 처리하기 위한 표준 프로그래밍 언어.
	- 데이터의 삽입, 조회, 수정, 삭제 등의 작업을 수행함
4. 트랜잭션
	- 데이터베이스의 상태를 변화시키는 하나의 논리적 작업 단위로, 전체가 성공하거나 전체가 실패하는 방식으로 이루어진다.
	- **TODO : ACID 속성, 동시성 문제, 트랜잭션 격리 수준 등은 추후 정리하기**
5. 파티셔닝, 샤딩
	- 파티셔닝 
		- 하나의 서버 내에서 테이블을 나누어 데이터를 효율적으로 관리하는 방식
		- 하나의 서버 내에서 대량의 데이터를 관리할 때 유용
	- 샤딩
		- 데이터를 여러 서버로 분산하여 저장하고 성능을 확장하는 방식
		- 사용자가 급증하는 대규모 서비스처럼 서버를 확장해야 할 때 사용

# Network

1. google.com을 주소창에 입력하면 무슨 일이 일어나는가?
	1. 브라우저가 입력받은 URL을 통해 서버에 접속하고자 함. 
	2. 3-way handshake 발생 (연결 요청->연결 수락 준비 완료 -> 연결 완료 신호)
	3. 브라우저는 HTTP를 통해 서버에 요청을 함
	4. 서버는 요청을 받아 HTML, CSS, JavaScript 등을 포함한 HTML 파일을 응답으로 보냄
	5. 브라우저는 서버로부터 받은 HTML, CSS, JavaScript 파일을 처리함.
	6. 응답을 받으면 브라우저는 완성된 웹 페이지를 사용자에게 보여줌
2. HTTP & HTTPS
	- HTTP (HyperText Transfer Protocol)
		- 클라이언트와 서버 간 데이터를 주고 받는 통신 규약
		-  URL로 데이터를 요청하고 응답을 받음
	- HTTPS (HyperText Transfer Protocol Secure)
		- 보안이 강화된 버전
		- 사용하는 이유 : 데이터 암호화, 무결성, 인증, SEO 
3. 로드 밸런싱
	- 서버나 자원에 오는 요청이나 트래픽을 고르게 분배하는 기술
	- 서버가 동시에 일을 나누어 처리하기 때문에, 서버의 과부화를 방지하고, 서비스의 응답 속도가 빨라짐
4. WS(Web Server) & WAS(Web Application Server)
    - Web Server
        - 정적인 컨텐츠(파일)를 제공하는 서버
        - HTML, CSS, 이미지 등 변하지 않는 파일들을 클라이언트(브라우저)에게 전달
            - 누가 요청을 보내도 같은 응답을 보낸다
    - WAS (Web Application Server)
        - 동적인 컨텐츠를 제공하는 서버
        - 사용자의 요청에 따라 데이터를 처리하여 다른 결과를 보여줌
            - WS로부터 요청을 받고, 비즈니스 로직 등을 처리하고 응답함
        - Java로 작성한 프로그램을 실행하고 결과를 사용자에게 전달