# Spring

1. Spring Framework (Spring VS SpringBoot)
   - 애플리케이션을 구축할 때 사용할 수 있도록 미리 정의된 구조와 도구 모음
   - Spring
     - Java 기반의 애플리케이션 개발을 위한 오픈소스 프레임워크 (한국에서는 웹 개발 프레임워크)
     - 사용하는 이유
       : 웹 사이트나 웹 서비스를 만들 때 필요한 기능들을 미리 구현하여, 개발자가 비즈니스 로직에만 집중할 수 있게 함
     - Spring 단독으로는 사용 불가능하고, tomcat을 설치해야 함. 그렇기 때문에 세부 설정을 모두 해줘야 함.
     - war로 압축됨 (web)
   - SpringBoot
     - Tomcat과 같은 WAS가 내장되어 있어, 복잡한 설정 없이 Spring을 더 쉽게 사용할 수 있게 해주는 도구 (자체적으로 사용 가능)
     - SpringBoot가 없다면? 직접 WAS를 만들어 줘야함
     - jar로 압축됨 (java)
     - 내가 원하지 않는 설정도 포함되어있어 무겁고, 자동화되어 눈으로 과정이 보이지 않음 (에러 파악이 어려움)
2. MVC
   Spring FrameWork에서 제공하는 웹 모듈로, **Model-View-Controller** 디자인 패턴을 기반으로 웹 애플리케이션을 구축함
   - Model
     - 애플리케이션의 데이터와 비즈니스 로직을 담당한다. ( + 데이터베이스와 상호작용)
     - Service & Repostiory가 해당
   - View
     - 사용자에게 보여지는 화면을 담당함 (모델 결과 시각화)
     - Rest API를 사용할 경우, JSON 형태의 데이터가 view
   - Controller
     - 사용자의 요청을 받아서 Model과 View를 연결하는 역할
     - 사용자 요청을 분기한다.
     - Controller가 해당
3. 3계층 아키택처 : 3가지 형태로 서비스를 분리함
   - Controller (Presentation Layer)
     - 클라이언트와의 상호작용을 담당함
     - 클라이언트로부터 요청을 받아 처리하고, 응답을 반환한다.
   - Service (Business Layer)
     - 비즈니스 로직을 구현함 (+ 유효성 검사)
     - Controller와 Repository를 연결해줌
   - Repository (Data Access Layer)
     - 데이터베이스와의 상호작용을 통해 데이터에 대한 CRUD를 실행함
     - CRUD : Create(생성), Read(조회), Update(수정), Delete(삭제)
4. DI (Dependency Injection) : 의존성 주입
   - 3계층 아키텍처에서 Controller는 Service를, Service는 Repository를 필요로 한다. 곧 하나의 클래스가 또 다른 클래스를 필요로 하는 것을 **의존성을 주입한다**고 함.
   - IoC의 구현체
   - 불변성을 보장하기 때문에 주로 생성자를 활용해 의존성을 주입한다. (그 외 수정자, 필드)
   - 장점
     - 객체 간의 결합도를 낮춤 (생성자를 통해 넣으면 mySQL이든 오라클이든 상관없어짐)
     - 테스트가 용이해짐 (내가 임시로 만든 repository로 테스트 가능. controller는 호출하는 역할만 해서, mock이어도 실행 가능)
     - 코드의 재사용성이 높아짐
5. IoC (Inversion of Control) : 제어의 역전
   - 객체를 생성하고 관리하는 주체가 개발자가 아닌 Spring과 같은 프레임워크가 담당하는 것
   - IoC가 필요한 이유?
     - 어떤 객체가 특정 구현체에 의존하고 있다면, 해당 구현체를 바꾸기만 하면 되므로 유연성이 높아진다.
6. Bean
   : 스프링 컨테이너에서 관리하는 자바 객체
   - 스프링 빈을 모아둔 스프링 컨테이너에서 Bean의 생성, 수정, 제거를 관리한다.
   - Bean으로 등록해야 하는 이유는?
     - Bean으로 등록되면, 스프링 컨테이너에서 싱글톤 패턴에 따라 각 클래스 별로 하나의 인스턴스를 자동으로 생성한다. 이 후 필요할 때 의존성 주입을 통해 다른 객체에 자동으로 주입된다.

**Lombock // Spring 에서 사용하는 annotation 구분하고 각 기능에 대해 공부하기!**

# DataBase

1. Index
   - 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
     (책의 목차 같은 역할)
   - 특정 열(컬럼)에 대한 빠른 조회를 가능하게 하기 때문에 자주 조회되는 컬럼에 인덱스를 생성하는 것이 좋음
   - 단점 : 용량을 차지함
   - Unique Index를 따로 생성함
   - 정렬 방법 : B-Tree, B+-Tree
2. Unique
   - 해당 컬럼에 중복된 값을 허용하지 않는 제약 조건
   - EX. 이메일 주소나 전화번호처럼 고유해야 하는 데이터에 설정
3. SQL (Structured Query Language)
   - 데이터베이스를 관리하고 데이터를 처리하기 위한 표준 프로그래밍 언어. (DB와 소통하는 언어)
   - 데이터의 삽입, 조회, 수정, 삭제 등의 작업을 수행함
4. 트랜잭션
   - 데이터베이스의 상태를 변화시키는 하나의 논리적 작업 단위로, 전체가 성공하거나 전체가 실패하는 방식으로 이루어진다.
   - 여러 SQL을 하나의 작업 단위로 묶음
   - **TODO : ACID 속성, 동시성 문제, 트랜잭션 격리 수준 등은 추후 정리하기**
5. 파티셔닝, 샤딩
   - 파티셔닝
     - 하나의 서버 내에서 테이블을 나누어 데이터를 효율적으로 관리하는 방식
     - 하나의 서버 내에서 대량의 데이터를 관리할 때 유용
   - 샤딩
     - 데이터를 여러 서버로 분산하여 저장하고 성능을 확장하는 방식
     - 사용자가 급증하는 대규모 서비스처럼 서버를 확장해야 할 때 사용

# Network

1. `google.com`을 주소창에 입력하면 무슨 일이 일어나는가?
   1. **URL 입력**
      사용자가 브라우저 주소창에 `google.com`을 입력
   2. **DNS 조회 (Domain Name System)**
      브라우저는 URL에 매핑된 IP 주소를 찾기 위해 DNS 서버에 요청을 보냄
      로컬 캐시, 호스트 파일, ISP의 DNS 서버 또는 글로벌 DNS 서버를 순서대로 확인함
      - IP (Internet Protocol)
        인터넷에서 통신하는 모든 기기는 고유한 주소인 IP 주소를 가지고 있는데, 사람들은 숫자로 이루어진 IP 주소를 기억하기 어렵기 때문에 `google.com`과 같은 도메인 이름을 사용함.
      - DNS 서버
        도메인 이름을 해당하는 IP 주소로 변환하는 역할을 하는 서버
      - 로컬 캐시
        브라우저에서 이전에 방문한 도메인과 IP 주소를 저장하므로, 재방문 시 DNS 조회를 건너뛰고 빠르게 연결 가능
      - 호스트 파일
        운영체제에 있는 파일로, 특정 도메인에 대해 미리 정의된 IP 주소를 설정할 수 있음
        (ex. 127.0.0.1 mywebsite.local 처럼 개발용으로 설정 가능)
      - ISP의 DNS 서버
        인터넷 서비스 제공자(ISP, ex. KT, SKT)가 제공하는 DNS 서버
      - 글로벌 DNS 서버
        전 세계에서 사용되는 공용 DNS 서버를 의미 (ex. Google의 DNS 서버(8.8.8.8))
   3. **TCP 연결 설정 (Transmission Control Protocol)**
      브라우저는 IP 주소를 얻은 후, 서버와의 통신을 위해 TCP 연결을 설정
      이 과정에서 3-way handshake 발생 (연결 요청->연결 수락 준비 완료 -> 연결 완료 신호)
      - TCP
        데이터를 인터넷 상에서 안전하고 신뢰성 있게 전송하는 프로토콜로, 데이터가 손실되거나 순서가 뒤섞이는 것을 방지함
      - 3-way handshake
        TCP 연결을 설정하는 과정으로, 클라이언트와 서버가 서로 통신 준비를 확인하는 단계
        - SYN (Synchronize) : C -> S 연결을 시작하겠다고 요청하는 신호를 보냄
        - SYN-ACK(Synchronize-Acknowledge) : S -> C 서버가 요청을 받았음을 확인하고, 동시에 자신도 준비되었음을 알림
        - ACK(Acknowledge) : 클라이언트가 서버의 응답을 확인하고 연결이 완료됨
   4. **HTTPS를 사용한 보안 연결**
      브라우저와 서버가 인증서를 교환하고 암호화 키를 생성해 안전한 통신을 준비
      (HTTPS : 데이터를 암호화 -> 443 포트로 진입하여 데이터를 요청)
   5. **HTTP 요청 전송**
      브라우저가 서버에 HTTP GET 요청을 보냄
      요청 헤더에는 브라우저 종류, 쿠키, 캐시 정보 등이 포함
   6. **서버 응답**
      서버는 요청을 처리한 후 HTML, CSS, JavaScript, 이미지 등의 리소스를 응답으로 보냄
   7. **브라우저 렌더링**
      브라우저는 받은 HTML 문서를 파싱하며 DOM 트리를 생성
      CSS, JavaScript를 처리하며 스타일을 적용하고 동적 동작을 준비함
      이후, 화면에 페이지를 렌더링함
   8. **추가 요청**
      HTML 문서에 포함된 외부 리소스(이미지, JS, CSS 등)를 추가로 요청하고 다운로드함
   9. **최종 표시**
      모든 리소스가 로드된 후 사용자가 완전한 웹페이지를 볼 수 있음
2. HTTP & HTTPS
   - HTTP (HyperText Transfer Protocol)
     - 클라이언트와 서버 간 데이터를 주고 받는 통신 규약
     - URL로 데이터를 요청하고 응답을 받음
     - 보안에 취약함
     - 기본 포트 : 80 (cf. 8080은 tomcat에서 제공하는 것)
   - HTTPS (HyperText Transfer Protocol Secure)
     - 인증서를 통해 HTTP의 데이터를 암호화하여보안을 강화한 버전
     - 암호화키
       - 대칭키 : 서버와 클라이언트가 같은 키를 가짐
         암호화 시킨 키를 그대로 가진 상태로 복호화
       - 비대칭키
         - 공개키 : 클라이언트가 공개키로 암호화
         - 비공개키 : 서버가 비공개키로 복호화
     - 사용하는 이유 : 데이터 암호화, 무결성, 인증, SEO
     - 기본 포트 : 443
3. 로드 밸런싱
   - 서버나 자원에 오는 요청이나 트래픽을 고르게 분배하는 기술
   - 서버가 동시에 일을 나누어 처리하기 때문에, 서버의 과부화를 방지하고, 서비스의 응답 속도가 빨라짐
4. WS(Web Server) & WAS(Web Application Server)
   - Web Server
     - 정적인 컨텐츠(파일)를 제공하는 서버
     - HTML, CSS, 이미지 등 변하지 않는 파일들을 클라이언트(브라우저)에게 전달
       - 누가 요청을 보내도 같은 응답을 보낸다
   - WAS (Web Application Server)
     - 동적인 컨텐츠를 제공하는 서버
     - 사용자의 요청에 따라 데이터를 처리하여 다른 결과를 보여줌
       - WS로부터 요청을 받고, 비즈니스 로직 등을 처리하고 응답함
     - Java로 작성한 프로그램을 실행하고 결과를 사용자에게 전달
