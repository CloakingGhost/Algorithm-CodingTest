
- ORM
- JPA
    - 영속성, Dirty Checking
    - 연관관계(다대다 처리)
    - N + 1 문제 해결
    - Spring Data JPA
    - Hibernate


#### **ORM
(Object-Relational Mapping)

- 객체와 데이터베이스를 매핑해주는 기술
   => SQL 대신 객체를 통해 데이터를 처리함

- 객체와 데이터베이스를 연결해주는 도구 또는 기법=> 데이터베이스의 데이터를 객체로 매핑하고, 객체를 통해 데이터베이스 작업을 수행할 수 있게 해줘.

- **ORM의 개념**: 객체와 데이터베이스를 매핑해주는 도구.
- **언제 사용**: 객체 지향 환경에서 데이터베이스 작업이 필요할 때.
- **왜 사용**: SQL 작성 부담을 줄이고 생산성과 유지보수를 향상시키기 위해.
- **장점**: 생산성 향상, 데이터베이스 독립성, 코드 가독성.
- **단점**: 복잡한 쿼리 처리 어려움, 성능 문제, 학습 곡선.
- **단점 극복 방법**: 네이티브 SQL 사용, 캐싱 및 로깅 활용, 성능 분석 및 최적화.

*결론*
*ORM은 SQL 대신 객체로 데이터베이스를 다루게 해 생산성을 높이고 유지보수를 쉽게 하지만, 복잡한 쿼리와 성능 문제는 주의해야 함.*

---


#### **JPA
(Java Persistence API)

- Java 애플리케이션에서 데이터베이스를 다룰 수 있는 표준 API
- Java 객체와 관계형 데이터베이스 간의 매핑을 관리해주는 ORM 기술의 표준 명세
- JPA 자체는 인터페이스 모음이고, Hibernate 같은 구현체를 사용해 동작해.

**1. JPA란?**

- Java에서 ORM을 구현하는 **표준 API**로, 객체와 데이터베이스 간의 매핑을 관리함.

**2. 언제 사용?**

- Java 애플리케이션에서 데이터 저장, 조회, 수정, 삭제가 필요할 때.
- 데이터베이스 독립성과 객체 지향 설계를 활용하고 싶을 때.

**3. 장점**

- **생산성 향상**: SQL 없이 데이터 작업 가능.
- **데이터베이스 독립성**: 다양한 DBMS 지원.
- **객체 지향적 개발**: 객체 모델 중심 설계 가능.

**4. 단점**

- 복잡한 쿼리 처리 어려움.
- 성능 문제 발생 가능.
- 학습 곡선이 있음.

**5. 단점 극복 방법**

- **JPQL/네이티브 SQL** 활용.
- **Lazy/Eager Loading 최적화** 및 캐싱 활용.
- 실행 쿼리 로깅으로 비효율 분석 및 튜닝.


*결론*
JPA는 Java의 ORM 표준으로 개발 생산성을 높이고 객체 지향적 설계를 가능하게 하지만, 성능 최적화와 복잡한 쿼리 처리는 주의가 필요함.

---
#### 영속성

- **객체와 데이터베이스 간의 데이터 상태를 관리**하는 개념
- JPA에서는 **영속성 컨텍스트(Persistence Context)**를 통해 엔티티 객체를 관리

### **영속성(Persistence)이 언제 쓰이는가?**

1. **데이터 상태를 관리할 때**
    
    - 엔티티 객체의 생명주기(비영속 → 영속 → 준영속 → 삭제)를 관리.
    - 엔티티를 데이터베이스에 저장, 조회, 수정, 삭제할 때 사용.
2. **데이터 변경 자동 반영이 필요할 때**
    
    - 객체의 상태 변경을 데이터베이스에 자동으로 동기화하고 싶을 때 사용.
3. **트랜잭션 내에서 데이터 일관성을 유지할 때**
    
    - 트랜잭션 범위 내에서 같은 데이터에 대해 일관성을 보장하기 위해 사용.

---

#### Dirty Checking

- JPA의 **영속성 컨텍스트(Persistence Context)**에서 관리되는 엔티티 객체의 상태를 자동으로 감지하여,  
객체의 변경 내용을 데이터베이스에 자동으로 반영하는 기능

**1. Dirty Checking이란?**

- JPA가 영속성 컨텍스트 내에서 객체 상태 변화를 자동으로 감지해, 데이터베이스에 변경 사항을 자동으로 반영하는 기능.

**2. 언제 사용?**

- 트랜잭션 내에서 엔티티 객체의 필드 값을 수정할 때.

**3. 장점**

- SQL 작성 없이 변경 자동 반영 → **생산성 향상**.
- 데이터베이스와 객체 간의 **자동 동기화**.
- 데이터의 **일관성 보장**.

**4. 단점**

- **성능 비용**: 변경 감지에 메모리/CPU 사용 증가.
- **불필요한 쿼리** 발생 가능.
- 트랜잭션 의존성.

**5. 단점 극복 방법**

- `@DynamicUpdate`로 변경된 필드만 반영.
- 필요한 경우 JPQL/네이티브 SQL로 직접 처리.
- 트랜잭션 범위를 최소화하고 불필요한 필드 변경 방지.

*결론*
*Dirty Checking은 객체 변경을 자동으로 감지하고 반영해 개발 생산성을 높이지만, 성능 이슈는 최적화가 필요함*

---

### JPA 연관관계
- JPA에서 연관관계는 **엔티티 간의 관계를 매핑**하는 것

**1. JPA 연관관계란?**

- 객체 간의 참조를 데이터베이스의 외래 키와 매핑해주는 JPA의 기능.

**2. 언제 사용?**

- 엔티티 간의 관계를 객체 중심으로 관리하고 싶을 때.

**3. 장점**

- 객체 지향적 설계 가능.
- SQL 작성 감소 및 생산성 향상.
- 데이터 자동 처리와 지연 로딩 지원.

**4. 단점**

- 복잡한 설정.
- Lazy Loading으로 인한 성능 문제.
- N+1 문제 발생 가능.

**5. 단점 극복 방법**

- 단방향 매핑 기본, Fetch 전략 최적화.
- Fetch Join과 DTO로 성능 개선.
- BatchSize로 지연 로딩 최적화.

*결론*
*JPA 연관관계는 객체 간 관계를 매핑해 생산성을 높여주지만, 성능 최적화를 위해 Fetch 전략과 JPQL 활용이 중요함*

---

#### N+1

- **N+1 문제**는 JPA에서 **지연 로딩(Lazy Loading)** 전략으로 연관된 데이터를 가져올 때 발생하는 성능 문제

**1. N+1 문제란?**

- 기본 엔티티 조회 시 연관된 데이터를 가져오기 위해 **N번의 추가 쿼리**가 발생하는 문제.

**2. 왜 발생하는가?**

- Lazy Loading으로 연관 데이터를 개별적으로 조회할 때.

**3. 해결 방법**

1. Fetch Join으로 연관 데이터를 한 번에 조회.
2. `@EntityGraph`로 선언적 Fetch 전략 설정.
3. BatchSize로 Lazy Loading 성능 최적화.
4. 필요한 데이터만 가져오는 DTO 사용.
5. Fetch 전략을 적절히 설계.

*결론*
*N+1 문제는 지연 로딩으로 발생하며, Fetch Join, BatchSize, DTO 등을 사용해 해결할 수 있음.*

---

#### Spring Data JPA
- **Spring Framework**에서 제공하는 **JPA(Java Persistence API)**를 간편하게 사용할 수 있도록 도와주는 모듈
- JPA를 더 효율적이고 생산적으로 사용할 수 있도록 여러 기능을 추가해서, **데이터베이스 작업**을 쉽게 처리할 수 있게 해줘.

**1. Spring Data JPA란?**

- JPA를 더 간편하게 사용할 수 있도록 도와주는 Spring 모듈로, 쿼리 자동 생성과 페이징, 정렬 등의 기능을 제공함.

**2. 언제 사용?**

- 데이터베이스와 상호작용하며 CRUD 작업, 페이징, 정렬 등 생산성을 높이고 싶을 때.

**3. 장점**

- 코드 간소화, 자동 쿼리 생성, JPQL 및 네이티브 쿼리 지원, 페이징과 정렬 간편화.

**4. 단점**

- 복잡한 비즈니스 로직의 구현 어려움, 성능 제어 어려움, 테스트 복잡성.

**5. 단점 극복 방법**

- JPQL/네이티브 쿼리 활용, 성능 최적화(Fetch Join, BatchSize), 커스텀 Repository 작성.

*결론*
*Spring Data JPA는 JPA를 간편하게 사용할 수 있게 해주는 도구로, 기본 쿼리 자동화와 생산성을 높이지만, 복잡한 로직에서는 성능 최적화와 직접적인 제어가 필요함.*

---

#### Hibernate
- **Java** 언어에서 사용하는 **ORM(Object-Relational Mapping) 프레임워크**로, 객체와 관계형 데이터베이스의 데이터를 매핑하여 SQL 없이 데이터베이스 작업을 할 수 있도록 도와주는 도구

**1. Hibernate란?**

- Java 언어에서 사용하는 ORM 프레임워크로, 객체와 데이터베이스를 매핑해 데이터를 효율적으로 관리할 수 있도록 도와줌. JPA의 대표적인 구현체.

**2. 왜 사용?**

- SQL 없이 데이터베이스 작업 가능, 생산성 향상, 데이터베이스 독립성 제공.

**3. 장점**

- 자동화된 CRUD, 데이터베이스 독립성, 캐시를 통한 성능 최적화, 유연한 쿼리 작성.

**4. 단점**

- 학습 곡선, 퍼포먼스 문제, 복잡한 SQL 처리 한계.

**5. 단점 극복 방법**

- Fetch 전략 최적화, 네이티브 SQL 활용, 캐시 사용, 성능 모니터링.

*결론*
*Hibernate는 JPA 구현체로, 객체와 데이터베이스를 매핑하여 SQL 없이 데이터 처리를 가능하게 하지만, 성능 튜닝과 설계가 중요함.*