
###### Spring
- Spring Framework
	- Spring  vs SpringBoot
- MVC
- DI
- Ioc
- Bean
###### DB
- Index
- Unique
- SQL
- 파티셔닝, 샤딩
###### Network
- google.com을 주소창에 입력하면 무슨 일이 일어나는가?
- HTTP/HTTPS
- 로드 밸런싱
- WS(Web Server) / WAS(Web Application Server)

### **Spring
- 자바 애클리케이션을 개발할 때 유용한 도구와 기능을 제공하는 프레임워크
- Java 기반의 애플리케이션 개발을 위한 오픈소스 프레임워크 (현재 가장 널리 사용되는 Java 프레임워크)

#### **Spring의 특징**

1. **POJO 기반 개발**
    
    - POJO(Plain Old Java Object): 일반적인 자바 객체를 사용해 애플리케이션 개발이 가능하도록 설계됨.
    - 복잡한 기술을 단순화하면서, 코드의 재사용성과 확장성을 높여줌.
2. **DI (Dependency Injection)**
    
    - 객체 간의 의존성을 쉽게 관리할 수 있도록 지원.
    - 개발자는 객체를 직접 생성하지 않고, Spring이 생성해서 필요한 곳에 주입.
3. **AOP (Aspect-Oriented Programming)**
    
    - 비즈니스 로직과 공통 기능(로그, 트랜잭션 등)을 분리.
    - 코드의 중복을 줄이고 유지보수성을 높임.
4. **모듈화**
    
    - 다양한 모듈(예: Spring MVC, Spring Security, Spring Data)로 구성되어 필요한 기능만 사용할 수 있음.

#### **Spring의 단점**

- 설정 파일(XML이나 Java Config)이 많아지고 복잡해질 수 있음.
- 프로젝트 설정이 까다롭고 시간이 많이 걸릴 수 있음.


### **Spring Boot
-  Spring을 더 쉽게 사용할 수 있도록 만든 Spring의 확장판 (Spring을 편리하게 쓰도록 도와주는 도구)
- 복잡한 설정 없이 바로 개발 시작 가능
- 필요한 라이브러리들 자동 설치 / 서버 내장되어 있어 따로 설치할 필요 X
#### **Spring Boot의 특징**

1. **자동 설정(Auto Configuration)**
    
    - 설정 파일을 최소화해줌.
    - 예를 들어, 데이터베이스 연결이나 서버 설정 같은 작업을 Spring Boot가 자동으로 처리.
2. **내장 서버**
    
    - Tomcat이나 Jetty 같은 웹 서버가 내장되어 있어서, 별도의 서버 설치 없이 애플리케이션 실행 가능.
    - 간단히 애플리케이션을 실행하려면 `main()` 메서드를 실행하기만 하면 됨.
3. **스타터(Starters)**
    
    - 필요한 라이브러리를 쉽게 추가할 수 있도록 제공되는 기본 패키지.
    - 예: `spring-boot-starter-web`, `spring-boot-starter-data-jpa` 등.
4. **간단한 배포**
    
    - Spring Boot 애플리케이션은 `.jar` 파일 하나로 배포 가능.
    - 운영 환경에 빠르게 적용할 수 있음.
5. **Spring과 100% 호환**
    
    - Spring의 모든 기능을 사용할 수 있으면서, 설정 작업이 더 간단함.

#### **Spring Boot의 장점**

- **초기 설정**이 매우 간단.
- 프로젝트 개발 속도가 빠름.
- Spring보다 배우기 쉬움.

|  특징   |       Spring        |     Spring Boot      |
| :---: | :-----------------: | :------------------: |
| 설정 방식 |    복잡하고 수동 설정 필요    |     자동 설정으로 간단함      |
| 서버 사용 | 외부 서버(Tomcate 등) 필요 |       내장 서버 제공       |
| 러닝 커브 |       비교적 높음        |          낮음          |
| 배포 방식 |      WAR 파일 생성      | JAR 파일 생성, 간단히 실행 가능 |

-------


### **MVC
- 애플리케이션을 구조화하는 디자인 패턴
- Model - View - Controller 세 가지 주요 구성 요소로 나뉨
- 구성 요소를 분리하여 개발 => 코드의 재사용성과 유지보수성을 높이기 위해 사용

- **Model
	- 데이터와 관련된 모든 작업을 처리
	    - 애플리케이션의 데이터와 비즈니스 로직을 담당 (데이터베이스와 상호작용 + 비지니스 로직 포함)
    - Service와 Repository가 Model에 해당
- **View
    - 사용자에게 보여지는 화면을 담당한다. (UI)
	    - 데이터를 시각적으로 표현
	    - Model에서 받은 데이터를 표시 (UI 요소 렌더링하지만, 로직 처리는 하지 않음)
    - HTML, JSP, Thymeleaf 등이 View에 해당
    - REST API를 사용할 경우 JSON 형태의 데이터가 View가 됨
- **Controller
    - 사용자의 요청을 받아서 Model과 View를 연결하는 역할
	    - 사용자의 입력을 받아 적절한 로직(Model 호출)을 수행
	    - 결과 데이터를 View에 전달
    - @Controller 또는 @RestController 어노테이션을 사용

- **MVC 동작 흐름
1. 사용자가 요청을 보냄 (ex. URL 클릭)
2. Controller가 요청을 받고, 필요한 데이터를 Model에서 가져옴
3. Model이 데이터를 처리하고 결과를 반환
4. Controller는 처리된 데이터를 View에 전달
5. View가 데이터를 표시하고 사용자에게 응답

- **MVC 장점
1. 유지보수성
	1. 각 역할이 분리되어 있어 코드 변경이 쉬움
		1. ex. UI 변경할 때 View만 수정하면 됨
	2. 재사용성
		1. Model, View, Controller를 각각 독립적으로 재사용 가능
	3. 테스트 용이성
		1. 각 구성 요소를 분리해서 테스트할 수 있음

- **MVC 단점
- 프로젝트가 커지면 Controller가 복잡해질 수 있음
	- MVC 구조는 역할을 명확히 나누기 때문에 많은 파일과 구성 요소가 필요함 -> 간단한 프로젝트라면 개발이 번거로워짐
	- Controller는 사용자 요청 처리하고 Model과 View 연결하는 역할 하는데, 비지니스 로직이 Controller로 몰리면 비대하고 복잡해짐 -> 코드 읽기 어렵고 관리 힘듬듬
- View와 Controller 간의 강한 연결이 단점이 될 수 있음
	- Controller는 View에 데이터 전달하고, View는 그걸 렌더링하는데 의존성 강해지면, View 수정할 때 Controller 코드도 변경해야 할 수 있음

-----
### **IoC

- 제어의 역전(Inversion of Control)
- 객체의 생성과 관리를 개발자가 아닌 프레임워크가 담당하는 것을 의미
	- 기존에는 개발자가 직접 객체 생성 관리 => 스프링에서는 컨테이너가 대신 관리
- IoC의 구현체가 DI

### **IoC의 동작 방식**

IoC는 주로 **의존성 주입(DI, Dependency Injection)**이라는 방식으로 구현됩니다.

1. **객체 생성과 관리**:  
    IoC 컨테이너(Spring)가 객체를 생성하고 관리합니다.
2. **의존성 주입**:  
    IoC 컨테이너가 객체 간의 의존성을 자동으로 연결합니다.

### **IoC의 필요성**

#### **1. 의존성 문제 해결**

개발자가 직접 객체를 생성하고 연결하면, 코드가 서로 강하게 의존하게 됩니다(**높은 결합도**).  
IoC를 통해 객체 간의 의존성을 줄여서 **유지보수성을 높이고** 코드를 더 유연하게 만들 수 있습니다.

#### **2. 테스트 용이성**

- IoC는 객체를 쉽게 교체하거나 Mock 객체를 주입할 수 있어 테스트 작성이 쉬워집니다.

#### **3. 코드 간소화**

- 객체 생성 및 의존성 연결 코드를 줄일 수 있어 코드가 간결해집니다.


----


### **DI

- 의존성 주입(Dependency Injection)
- 객체가 필요로 하는 의존성을 외부에서 주입받는 방식
	- 의존성 : 한 클래스가 다른 클래스를 필요로 하는 것을 의미
- 스프링이 자동으로 객체 생성하고 주입해줌

- **DI 장점
1. 객체 간의 결합도를 낮춰줌
	1. 느슨한 결합 => 어떤 구현체든 주입 가능
2. 테스트가 용이함
3. 코드의 재사용성이 높음


### 생성자 주입(Constructor Injection)

- 생성자를 통해 의존성을 주입받는 방식이다.
- 특징
    - 불변성 보장: 한번 주입된 후 변경할 수 없다.
    - 필수 의존성에 사용: 객체 생성 시점에 모든 의존성이 주입된다.
    - 순환 참조 방지: 컴파일 시점에 순환 참조를 확인할 수 있다.
    - 생성자가 하나면 @Autowired 생략이 가능하다

### 수정자 주입(Setter Injection)

- setter 메서드를 통해 의존성을 주입받는 방식이다.
- 특징
    - 선택적 의존성에 사용: 없어도 객체 생성이 가능하다.
    - 의존성 변경 가능: 런타임에 의존성을 변경할 수 있다.

### 필드 주입(Field Injection)

- 필드에 직접 의존성을 주입하는 방식이다.
- 특징
    - 코드가 간결하다.
    - 외부에서 변경이 불가능하다.
    - 테스트하기 어렵다.
    - 순환 참조 발생 가능하다.
    - **권장하지 않는 방식이다.**


### **Bean

- 스프링 컨테이너 : 스프링 빈을 모아두고 관리하는 장소
	- 스프링 빈의 생명주기를 관리하는 핵심 요소
	- 객체의 생성, 관리, 제거를 담당

- 스프링 빈 : 스프링 컨테이너가 관리하는 자바 객체
	- 애플리케이션의 구성 요소를 재사용 가능하고 효율적으로 관리할 수 있도록 돕는 도구
	

- 빈 등록 방법
	- 컴포넌트 스캔과 @Component 어노테이션을 통한 자동 등록
	- 자바 설정 클래스에서 @Bean을 통한 수동 등록


- **스프링 빈의 장점
1. **객체 관리 자동화**:
    - 객체 생성, 의존성 주입, 소멸 등을 Spring 컨테이너가 관리.
2. **결합도 감소**:
    - 객체 간의 의존성을 코드에서 직접 처리하지 않아도 됨.
3. **유지보수성 향상**:
    - 빈 설정과 관리가 중앙 집중화되어 코드 변경이 쉬움.

---



- **DB(DataBase)
	- 체계적으로 구조화된 데이터의 집합
	- DBMS(Database Management System) : 데이터를 효율적으로 저장, 조회, 수정, 삭제할 수 있도록 도와주는 시스템 (Oracle, MySql, PostgreSQL, SQLite 등)

- **관계형 데이터베이스
	- 데이터를 테이블로 구성하며, 각 테이블은 행과 열로 구성됨
	- 정보를 표 형식(테이블)로 저장하며, 행과 열은 다양한 데이터 속성과 데이터 값 간의 다양한 관계를 나타냄
	- 자료를 여러 테이블로 나누어서 관리하고, 테이블간 관계를 설정해 여러 데이터를 쉽게 조작할 수 있음
	- SQL을 사용하여 데이터를 관리하고 검색

---

### **Index

- 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
	 -> 책의 색인처럼, 특정 데이터를 더 빠르게 찾을 수 있도록 도와주는 역할
- 특정 열(컬럼)에 대해 정렬된 상태를 유지 (B Tree, B+ tree)
- 검색 속도는 빨라지지만, 데이터 입력/수정/삭제는 조금 더 느려질 수 있음
- 추가 저장 공간 필요


#### **장점**

1. **빠른 데이터 검색**:
    - 데이터 검색 속도를 크게 향상
2. **정렬 최적화**:
    - 인덱스가 생성된 컬럼은 정렬이 빠르게 처리
3. **중복 방지**:
    - `UNIQUE` 인덱스를 사용하면 중복 데이터를 자동으로 방지

#### **단점**

1. **추가 저장 공간 필요**:
    - 인덱스는 별도의 자료구조로 관리되므로 디스크 공간을 더 차지
2. **쓰기 작업 성능 저하**:
    - 데이터를 삽입, 수정, 삭제할 때 인덱스도 함께 갱신해야 하므로 성능이 느려질 수 있음
3. **과도한 인덱스는 역효과**:
    - 너무 많은 인덱스는 성능 저하와 관리 복잡성을 초래


#### **사용할 때**

1. 검색이 빈번한 컬럼 (예: ID, 이름 등)
2. 테이블이 매우 큰 경우
3. 정렬이나 범위 검색이 자주 발생하는 경우

#### **사용하지 않을 때**

1. 데이터가 자주 변경되는 컬럼 (삽입/수정/삭제가 많을 때)
2. 작은 테이블 (전체 스캔이 더 빠를 수 있음)
3. 매우 낮은 선택도를 가진 컬럼 (예: 성별처럼 값의 종류가 적은 경우)

---

### **Unique

- 데이터베이스 테이블의 특정 컬럼(열)에 중복된 값이 들어갈 수 없도록 제한하는 제약 조건
	- 각 값이 고유해야 하며, 중복된 값을 저장할 수 없음

#### **특징

- **중복 방지
    - UNIQUE가 설정된 컬럼의 값은 테이블 내에서 중복될 수 없음
    - 하지만 `NULL` 값은 중복으로 간주하지 않으므로, 하나 이상의 `NULL` 값을 허용
- **다른 제약 조건과의 차이
    - PRIMARY KEY도 고유한 값을 요구하지만, PRIMARY KEY는 하나의 테이블에 **하나만 생성 가능**하며, 반드시 **NOT NULL**이어야 함
    - 반면 UNIQUE는 테이블에 **여러 개 설정 가능**하며, `NULL` 값을 허용


|       특징       |   UNIQUE   | PRIMARY KEY |
| :------------: | :--------: | :---------: |
|   **고유성 보장**   |     O      |      O      |
| **NULL 허용 여부** | 허용(한 번 이상) |   허용되지 않음   |
| **테이블당 개수 제한** |  여러 개 가능   |   하나만 가능    |
| **인덱스 생성 여부**  |  자동으로 생성됨  |  자동으로 생성됨   |

---

### **SQL

- Structured Query Language
	- 데이터베이스를 관리하고 데이터를 처리하기 위한 표준 프로그래밍 언어 (구조화된 쿼리 언어)
		-> 관계형 데이터베이스에 정보를 저장하고 처리하기 위한 프로그래밍 언어
	- 데이터의 삽입, 조회, 수정, 삭제 등의 작업을 수행
		-> 데이터베이스에 쿼리를 보내 원하는 데이터를 가져오거나 삽입할 수 있음

*Q. 쿼리란? 
: '질의문' 저장되어 있는 데이터를 필터하기 위한 질의문 / 검색할 때 입력하는 검색어가 일종의 쿼리

#### SQL 명령어 분류

- DDL (Data Definition Language, 데이터 정의어)
    - 데이터베이스 구조를 정의하고 변경하는 명령어 (테이블, 스키마 등)
    - CREATE(생성) / ALTER(변경) / DROP(삭제) / TRUNCATE(데이터 전체 삭제) / RENAME(이름 변경)
- DML (Data Manipulation Language, 데이터 조작어)
    - 데이터를 조작(입력, 수정, 삭제, 조회)하는 명령어
    - SELECT(조회) / WHERE(조건절) / INSERT(삽입) / UPDATE(수정) / DELETE(삭제)
- DCL (Data Control Language, 데이터 제어어)
    - 데이터베이스의 접근 권한을 제어하는 명령어 (사용자에게)
    - GRANT(사용권한 부여) / REVOKE(사용권한 회수)
- TCL (Transaction Control Language, 트랜잭션 제어어)
    - 트랜잭션을 제어하는 명령어
    - COMMIT(트랜잭션 영구 적용) / ROLLBACK (트랜잭션 변경 사항 취소)
	- 트랜잭션
	    - 데이터베이스의 상태를 변화시키는 하나의 논리적 작업 단위 (데이터 무결성 유지)
	    - ex) a가 b에게 5만원을 송금한다고 했을 때,
	        - a 계좌에서의 출금
	        - b 계좌에서의 입금
	         -> 작업(출금과 입금)은 반드시 모두 성공하거나 모두 실패한다

*Q. 트랜잭션이란?
*데이터베이스에서 하나의 작업 단위로, 여러 개의 작업을 하나로 묶어서 처리할 수 있도록 함
모든 작업이 성공적으로 끝나거나(commit), 모두 실패하여 원래 상태로 돌아가게(rollback) 해야 하는 성질을 가짐

-> ACID 속성을 충족해야 하며, 데이터 일관성, 무결성 보장하는데 중요한 역할을 함
#### **1) Atomicity (원자성)**

- 트랜잭션 내의 모든 작업은 **하나의 작업처럼 처리**됩니다.
- 작업이 모두 성공하거나, 실패하면 모두 취소되어야 합니다.
    - 예: 은행 이체에서 돈을 보내고 받는 두 작업이 있습니다. 두 작업 모두 성공하거나, 둘 다 실패해야 합니다.

#### **2) Consistency (일관성)**

- 트랜잭션이 실행되기 전과 후의 데이터베이스 상태는 일관성을 유지해야 합니다.
    - 예: 은행 계좌에서 출금할 때, 계좌의 잔액이 음수가 될 수 없도록 해야 합니다.

#### **3) Isolation (격리성)**

- 트랜잭션이 진행 중일 때 다른 트랜잭션은 이를 **간섭하지 못하도록** 격리해야 합니다.
- 예를 들어, 동시에 두 사용자가 같은 계좌에서 돈을 빼려고 하면, 한 사람의 트랜잭션이 완료될 때까지 다른 사람은 기다려야 합니다.

#### **4) Durability (내구성)**

- 트랜잭션이 완료되면 그 결과는 **영구적으로 기록**되어야 하며, 시스템 오류나 장애가 발생해도 데이터가 손실되지 않아야 합니다.
    - 예: 트랜잭션이 끝난 후 시스템이 다운되더라도 이미 변경된 데이터는 복구되어야 합니다.


---

### **Partitioning, Sharding

- 데이터베이스를 분할하는 방법
	-> 데이터베이스 성능 최적화, 확장성, 관리 용이성 등을 고려하여 상황에 맞게 적용
-  **파티셔닝**: 데이터베이스 내에서 하나의 테이블을 여러 파티션으로 나누어 성능을 최적화하는 방법입니다. 동일한 데이터베이스 서버 내에서만 데이터 분할이 이루어집니다.
- **샤딩**: 데이터를 여러 **서버**에 나누어 저장하는 방식으로, 수평 확장성을 제공하며 여러 서버에 걸쳐 데이터가 분산됩니다.

#### **파티셔닝
- 큰 데이터베이스 테이블을 작은 부분으로 나누는 기법
	-> 각 부분을 파티션(partition)이라고 부름
	-> 각 파티션은 논리적으로 동일한 테이블의 일부로 간주
- 하나의 테이블을 여러 개의 테이블로 물리적으로 분할 저장

- **성능 향상**: 데이터를 여러 파티션으로 분할하여 각 파티션을 독립적으로 관리하고 쿼리할 수 있어 성능이 향상됩니다.
- **관리 용이성**: 테이블이 너무 커지면 관리가 어려워지는데, 이를 작은 파티션으로 나누어 관리가 용이해집니다.
- **데이터 분할**: 대량의 데이터를 나누어 저장하여 특정 데이터를 쉽게 조회하거나 삭제할 수 있습니다.

#### **샤딩
- 동일한 스키마를 가지고 있는 여러 대의 데이터베이스 서버들에 데이터를 작은 단위로 나누어 분산 저장
	-> 작은 단위를 샤드(shard)라고 부름
- 수평 파티셔닝과 비슷하지만, 파티셔닝은 하나의 서버 / 샤딩은 여러 서버에 분산함
- 데이터를 물리적으로 다른 서버로 분산
	-> 여러 샤드에 있는 데이터 조인의 어려움
	-> 한 샤딩에 데이터가 몰리는 경우 성능 저하 발생

- **성능 향상**: 하나의 데이터베이스에 모든 데이터를 저장하는 대신, 여러 서버에 데이터를 분배하여 성능을 높일 수 있습니다.
- **확장성**: 데이터가 증가함에 따라 더 많은 샤드를 추가하여 데이터베이스를 수평으로 확장할 수 있습니다.
- **부하 분산**: 트래픽을 여러 서버에 분배하여 특정 서버에 부하가 집중되는 것을 피할 수 있습니다.

#### **파티셔닝, 샤딩 차이점**

- **목적**: 파티셔닝은 **한 서버 내에서** 성능을 향상시키기 위해 데이터를 분할하는 기법이고, 샤딩은 **여러 서버로** 데이터를 분산시켜 확장성과 성능을 향상시키는 기법입니다.
- **운영**: 파티셔닝은 **한 데이터베이스 서버** 내에서 데이터를 나누며, 샤딩은 **여러 서버**에 데이터를 분배합니다.

---
###### Network
- google.com을 주소창에 입력하면 무슨 일이 일어나는가?
- HTTP/HTTPS
- 로드 밸런싱
- WS(Web Server) / WAS(Web Application Server)


### **google.com을 주소창에 입력하면 무슨 일이 일어나는가?

 **사용자가 브라우저의 주소창에 'google.com'을 입력하면, 다음과 같은 과정이 발생합니다

1. **DNS 조회**: 브라우저는 'google.com'을 IP 주소로 변환하기 위해 DNS 서버에 질의를 보냅니다.
2. **IP 주소 반환**: DNS 서버는 'google.com'에 해당하는 IP 주소(예: 172.217.0.0)를 반환합니다.
3. **HTTP 요청**: 브라우저는 해당 IP 주소로 HTTP 요청을 보내 구글 웹 서버에 접속합니다.
4. **서버 응답**: 구글 웹 서버는 요청을 처리하고, HTML, CSS, JavaScript 등의 웹 콘텐츠를 응답으로 반환합니다.
5. **웹 페이지 렌더링**: 브라우저는 받은 콘텐츠를 해석하고 화면에 구글 홈페이지를 렌더링합니다.

**결론적으로, 이 과정은 매우 빠르게 이루어져 사용자가 'google.com'을 입력하면 몇 초 안에 구글 홈페이지를 볼 수 있습니다. 이 과정은 웹 페이지가 사용자에게 제대로 표시되도록 필요한 모든 리소스를 브라우저와 서버 간에 주고받는 복잡한 과정이지만, 일상적인 웹 서핑에서는 거의 실시간으로 처리됩니다.

- **DNS 조회**:  
    브라우저는 먼저 'google.com'이라는 도메인 이름을 **IP 주소**로 변환해야 합니다. 이를 위해 **DNS (Domain Name System)** 서버에 요청을 보냅니다. DNS는 인터넷에서 도메인 이름을 실제 IP 주소로 매핑하는 역할을 합니다. 이 단계에서 브라우저는 먼저 로컬 DNS 캐시를 확인하고, 없다면 DNS 서버에 질의를 보냅니다.
    
- **IP 주소 반환**:  
    DNS 서버는 'google.com'에 해당하는 IP 주소를 브라우저에 반환합니다. 예를 들어, 구글의 IP 주소는 172.217.0.0과 같은 값이 될 수 있습니다. 이 IP 주소는 실제로 구글 웹 서버가 위치한 서버의 주소입니다.
    
- **HTTP 요청**:  
    브라우저는 반환된 IP 주소로 **HTTP** 또는 **HTTPS** 프로토콜을 사용하여 구글 서버에 요청을 보냅니다. 이 요청에는 사용자가 요청한 웹 페이지, 예를 들어 'google.com'의 홈 페이지를 포함합니다.
    
- **서버 응답**:  
    구글 서버는 HTTP 요청을 처리하고, 요청한 웹 페이지를 포함한 콘텐츠(HTML, CSS, JavaScript, 이미지 파일 등)를 브라우저에 응답으로 보냅니다. 이때 서버는 클라이언트(브라우저)가 요청한 자료만을 보내지 않고, 웹 페이지의 렌더링에 필요한 모든 파일을 응답으로 전송합니다.
    
- **웹 페이지 렌더링**:  
    브라우저는 서버로부터 받은 HTML 문서를 해석하고, 그 안에 포함된 **CSS**, **JavaScript**, **이미지** 등의 리소스를 순차적으로 요청하여 화면에 표시합니다. 이 과정에서 **렌더링 엔진**이 HTML, CSS를 해석하고, JavaScript가 웹 페이지의 동적인 요소를 처리합니다.

---

### **HTTP/HTTPS
- 웹에서 클라이언트와서버 간에 데이터를 주고받는 프로토콜(통신 규약)

#### **HTTP (Hyper Text Transfer Protocol)
- 웹 브라우저와 웹 서버 간에 데이터를 주고받기 위한 표준 프로토콜
- 웹 페이지의 HTML, 이미지, 비디오 등 다양한 자원을 전송하는데 사용
- 보안이 없는 프로토콜 -> 데이터가 전송될 때 암호화되지 않은 상태로 전달

#### **특징:**

- **포트 번호**: 기본적으로 HTTP는 **80번 포트**를 사용합니다.
- **보안**: HTTP는 데이터를 암호화하지 않기 때문에 보안에 취약합니다. 예를 들어, 로그인 정보나 개인정보를 전송할 때 쉽게 노출될 수 있습니다.


#### **HTTPS (Hyper Text Transfer Protocol Secure)
- HTTP에 보안 기능을 추가한 프로토콜
	- HTTP를 사용하되, SSL/TLS 암호화를 통해 데이터를 암호화하여 전송
- 보안이 중요한 웹사이트에 사용

#### **특징:**

- **포트 번호**: 기본적으로 HTTPS는 **443번 포트**를 사용합니다.
- **보안**: HTTPS는 **SSL/TLS 암호화**를 사용하여 데이터를 암호화하고 전송하므로, 데이터를 가로채거나 변조하는 것이 매우 어렵습니다. 사용자와 서버 간의 통신이 암호화되어 개인정보나 중요한 데이터가 안전하게 보호됩니다.
- **인증서**: HTTPS에서는 **디지털 인증서**가 필요합니다. 서버는 인증서를 사용하여 자신이 신뢰할 수 있는 웹사이트임을 증명하고, 클라이언트(브라우저)는 서버가 신뢰할 수 있는 사이트인지 확인합니다.

### **HTTP와 HTTPS의 차이점**

| **구분**     | **HTTP**           | **HTTPS**                |
| ---------- | ------------------ | ------------------------ |
| **보안**     | 보안 없음 (암호화되지 않음)   | 보안 있음 (SSL/TLS 암호화 사용)   |
| **포트**     | 80번 포트             | 443번 포트                  |
| **속도**     | 상대적으로 빠름 (암호화 없어서) | 상대적으로 느릴 수 있음 (암호화 때문에)  |
| **인증서**    | 필요 없음              | 서버 인증서 필요                |
| **용도**     | 비보안 웹사이트           | 보안이 필요한 웹사이트 (로그인, 결제 등) |
| **URL 형식** | `http://`          | `https://`               |

*HTTP : 보안이 없는 웹 통신 프로토콜, 데이터를 암호화지 않고 전송*
*HTTPS : HTTP의 보안 버전으로, 데이터를 SS/TLS 암호화로 보호하며 웹사이트의 신뢰성과 보안성 높임*

---

### **로드 밸런싱

#### **Load Balancing
- 서버 간의 부하를 균등하게 분배하여 시스템의 성능과 안정성을 향상시키는 기술
- 웹 서버나 애플리케이션 서버 간에 사용자 요청을 분산시켜 부하를 고르게 분배하는 기술
	-> 시스템 성능을 최적화하고, 서버의 과부하를 방지하며, 고가용성과 확장성 제공

#### **로드 밸런싱의 주요 목적**

1. **성능 향상**: 여러 서버에 트래픽을 분산시켜 각 서버가 처리하는 양을 줄이고, 시스템의 처리 능력을 최대로 활용할 수 있습니다.
2. **고가용성**: 서버 중 하나가 다운되더라도, 로드 밸런서가 다른 서버로 요청을 우회시켜 시스템의 **중단 없는 서비스**를 유지할 수 있습니다.
3. **확장성**: 서버가 추가되면, 로드 밸런서는 새 서버로 요청을 자동으로 분배하여 **수평 확장**을 지원합니다.


#### **로드 밸런싱의 방식**

**"로드 밸런싱은 여러 방식으로 요청을 분배할 수 있습니다. 대표적인 알고리즘은 다음과 같습니다:**

- **라운드 로빈 (Round Robin)**: 순차적으로 각 서버에 요청을 분배합니다. 각 서버가 처리하는 부하가 대체로 동일할 때 유용합니다.
- **최소 연결 (Least Connections)**: 현재 연결이 가장 적은 서버로 요청을 보내는 방식입니다. 서버의 부하가 불균형할 때 효과적입니다.
- **가중 라운드 로빈 (Weighted Round Robin)**: 서버의 성능에 따라 가중치를 부여하여 요청을 분배합니다. 성능이 더 높은 서버는 더 많은 요청을 처리합니다.
- **IP 해시 (IP Hash)**: 클라이언트의 IP 주소를 해싱하여 특정 서버에 요청을 보냅니다. 특정 클라이언트가 항상 같은 서버로 연결될 수 있도록 합니다."**

#### **로드 밸런싱의 장점**

- **성능 개선**: 서버 간에 요청을 분배하여 과부하를 방지하고, 전체 시스템 성능을 향상시킬 수 있습니다.
- **고가용성**: 하나의 서버에 문제가 생겨도 다른 서버가 대체하여 서비스를 계속 제공할 수 있습니다.
- **확장성**: 서버를 추가하거나 제거할 때 로드 밸런서가 자동으로 트래픽을 조정하여 시스템을 확장하거나 축소할 수 있습니다.

#### **로드 밸런싱의 단점**

- **단일 장애 지점 (Single Point of Failure)**: 로드 밸런서 자체에 문제가 생기면 모든 트래픽이 영향을 받을 수 있습니다. 이를 방지하기 위해 여러 대의 로드 밸런서를 사용하거나, 고가용성 구성(HA)을 해야 합니다.
- **복잡성 증가**: 여러 서버를 관리하고 트래픽을 분배하는 시스템은 설정과 관리가 복잡할 수 있습니다.
- **비용**: 고성능 로드 밸런서나 클라우드 기반 로드 밸런서를 사용할 경우 비용이 발생할 수 있습니다.


*로드 밸런싱은 웹 애플리케이션의 트래픽을 여러 서버에 고르게 분배하여 성능을 향상시키고, 고가용성과 확장성을 제공하는 중요한 기술
-> 다양한 알고리즘을 통해 각 서버에 부하를 적절하게 분배하고, 서버 장애 시에도 서비스를 안정적으로 제공할 수 있도록 돕습니다.*

---

### **WS / WAS

#### **WS(Web Server) 웹 서버
- HTTP 프로토콜을 사용하여 클라이언트의 요청을 받아 웹 페이지나 정적 리소스(HTML, CSS, JavaScript, 이미지 등)를 응답하는 서버
- 주로 정적인 콘텐츠를 처리, 클라이언트의 요청에 맞는 파일을 전달하는 역할을 함

- **주요 기능**:
    
    - HTTP 요청을 받아들여 적절한 HTML, CSS, JavaScript 파일을 반환
    - **정적 파일 처리** (예: 이미지, CSS, JavaScript, HTML 파일 등)
    - 요청에 대한 리다이렉션이나 URL 재작성 처리
- **예시**: Apache HTTP Server, Nginx, IIS(Internet Information Services)

#### **WAS(Web Application Server) 웹 애플리케이션 서버
- 클라이언트의 요청을 받아 동적 콘텐츠를 생성하고 처리하는 서비스
- 웹 서버처럼 HTTP 요청을 받아들이고, 비지니스 로직을 처리하는 애플리케이션 서버
- 주로 서버 측에서 동적인 콘텐츠를 생성하여 클라이언트에게 전달

- **주요 기능**:
    
    - 클라이언트의 요청에 따라 **동적 콘텐츠**를 생성 (예: 데이터베이스 연동, 비즈니스 로직 처리)
    - 서버 측에서 **서블릿**, **JSP**, **Java EE** 등의 기술을 통해 동적인 웹 애플리케이션을 실행
    - **세션 관리**, **보안** 및 **트랜잭션 관리** 기능을 제공
- **예시**: Tomcat, Jetty, JBoss, WebLogic, WebSphere

|**특징**|**Web Server (WS)**|**Web Application Server (WAS)**|
|---|---|---|
|**주요 역할**|HTTP 요청을 받아 정적 콘텐츠 반환|동적 콘텐츠를 생성하고 처리|
|**처리하는 데이터**|정적 파일 (HTML, CSS, JS, 이미지 등)|동적 콘텐츠 (서블릿, JSP, 비즈니스 로직 등)|
|**응답 방식**|파일 기반 응답|애플리케이션 로직을 기반으로 한 동적 응답|
|**기술 스택**|HTTP 서버 (예: Apache, Nginx)|서블릿, JSP, EJB, Spring 등|
|**세션 관리**|없음 또는 제한적|세션 관리, 트랜잭션 처리 및 보안 처리|
|**비즈니스 로직**|처리하지 않음|비즈니스 로직을 처리하고 동적 페이지를 생성|

*웹 서버는 웹 애플리케이션 서버와 함께 사용되는 경우가 많음*
*->웹 서버는 클라이언트의 요청을 받고 정적 리소스를 제공한 뒤, 동적 콘텐츠가 필요한 경우에는 해당 요청을 웹 애플리케이션 서버로 전달*

- 예시:
    - **웹 서버**가 먼저 요청을 받아 **정적 파일**을 처리하고, **동적 페이지**나 **데이터베이스와의 연동**이 필요한 요청은 **WAS**로 전달하여 처리합니다.
    - 예를 들어, **Nginx**가 **웹 서버**로 정적 파일을 처리하고, 요청이 동적일 경우 **Tomcat**과 같은 **WAS**에 전달하여 비즈니스 로직을 처리하고 결과를 반환합니다.