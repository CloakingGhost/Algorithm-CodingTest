## Front-End (React)

<br/>

### 1. `component`

- 기능을 캡슐화해 재사용 가능한 커스텀 엘리먼트 생성
- 웹 앱에서 활용할 수 있도록 해주는 다양한 기술 모음
- UI를 독립적이고 재사용 가능한 일부분으로 분할하고 각 부분을 개별적으로 다룰 수 있음
- 주요 기술
    1. custom element : 사용자 인터페이스에서 원하는대로 사용할 수 있는 사용자 정의 요소 및 해당 동작을 정의할 수 있는 JavaScript API 세트
    2. shadow DOM : 캡슐화된 그림자 엘리먼트
        - 엘리먼트의 기능을 프라이빗하게 유지할 수 있어 다른 부분과 충돌없이 스크립트 및 스타일 작성 가능
    3. HTML 템플릿 : 렌더링된 페이지에 나타나지 않는 마크업 템플릿을 작성할 수 있게 해줌
        - 커스텀 엘리먼트의 구조 기반 재사용 가능

<br/>

### 2. `SPA`

- 싱글 페이지 어플리케이션(single-page application, SPA)
- 서버로부터 완전한 새로운 페이지 불러오지 않고 현재 페이지를 동적으로 다시 작성함으로써 사용자와 소통하는 웹 애플리케이션이나 웹 사이트
- 사용자가 서버에 완전히 새로운 페이지를 로드하지 않고 웹사이트 사용
- 사용자가 클릭 시 필요한 정보만 브라우저로 전송하고
- 장점
    1. 성능 향상 : 서버 요청을 받고 필요 요소만 업데이트해 로드 시간 단축 및 성능 개선
    2. 동적인 경험(반응성) : 전체 페이지 로드하지 않고 콘텐츠 업데이트
    3. 더욱 빠른 사용자 환경 : 한 번 로드되고 필요한 데이터만 페이지에 새로 고침됨
    4. 플랫폼 호환성 : 다양한 기기 및 플랫폼과 본질적으로 호환되지 않는, 태블릿, 모바일 기기에서 사용자 환경 제공
    5. 확장성 : 클라이언트 서버의 확장성 지원
- 단점
    1. 초기 로드 속도 느림
    2. SEO 문제 : SEO가 JavaScript에 의존하여 까다로울 수 있음
    3. 브라우저 지원 : 업데이트된 브라우저에서 고급 기능이 제대로 동작하지 않을 수 있음
    4. 보안 위험 : XSS(교차 사이트 스트립팅)와 같은 보안 문제
    5. 클라이언트 측 리소스 강도 : 클라이언트 측에 큰 바이트 저장하는 장치에 영향 미침
- 프레임워크
    - React, Vue, Angular
- **멀티 페이지 어플리케이션 (Multi Page Application, MPA)**

<br/>

### 3. `SSR`, `CSR`


: 웹 화면을 렌더링하는 방식

- **서버 사이드 렌더링 (Server Side Rendering, SSR)**
    
    - 서버측에서 페이지를 렌더링, 서버에서 브라우저에 보일 HTML 파일을 미리 준비해 응답해주는 형식
    - HTML 구문을 웹 서버가 전부 다 만듦
    - 각 페이지 URL마다 보여줄 내용이 미리 결정되어 있음
    - **흐름**
        1. 사용자가 웹 페이지에 접속 시 브라우저가 해당 URL 서버에 요청
        2. 서버는 이 URL 기준으로 어떤 페이지 렌더링할 지 결정
        3. 서버는 렌더링 엔진 이용해 페이지 렌더해 완성된 HTML을 브라우저에 응답함
        4. HTML 및 js 파일 등의 추가 리소스도 포함될 수 있음
    - **장점**
        - 초기 렌더링을 서버 측에서 수행해 검색 엔진 최적화에 유리
            - 검색엔진과 크롤러에 내용이 더 잘 인식될 수 있음
            - 검색 엔진들은 사용자의 쿼리에 따라 주기적으로 웹 탐색하고, 수많은 페이지를 URL 기준으로 수집해 DB에 저장
            - 크롤러는 웹 사이트의 지도와 링크 따라다니며 웹 페이지의 내용 수집하고 검색엔진 DB에 저장
        - 최초의 js 파일 로드 없이도 HTML이 이미 렌더되어 보여지기에 페이지 로딩이 빠름
    - **단점**
        - 일부분의 데이터만 따로 업데이트가 안됨
            
            → 일부분의 데이터만 변경이 필요하더라도 매번 전체 페이지를 새로고침하여 사용자가 웹 사이트를 살펴보기에 불편
            
    - **활용**
        - 정적인 웹 사이트에 주로 사용

- **클라이언트 사이드 렌더링 (Client Side Rendering, CSR)**
    - 웹 서버에서 초기 HTML을 받은 후 대부분의 내용을 브라우저가 동적으로 생성해 붙임
    - 페이지에 주요 내용을 동적으로 생성하는 방식
    - **흐름**
        1. 사용자가 메인 페이지에 접속
        2. 브라우저가 해당 웹 애플리케이션에 필요한 HTML과 정적 자원(CSS, JS, 이미지 리소스 등)을 서버에 요청
        3. 서버에서 기초적인 HTML과 자원들 전송
        4. 브라우저가는 HTML을 해석해 DOM 생성 및 자원들 다운로드
        5. 자바스크립트 엔진에 의해 js 파일 실행, 메인 페이지에 보여줄 컴포넌트들 동적 생성 및 렌더링
    - **다른 페이지 접속할 경우**
        1. 미리 모든 페이지에서 필요한 js 파일들 받아둠
        2. 특정 페이지 이동 시 해당 페이지에 필요한 js 파일 실행해 새로운 컴포넌트 렌더링 및 화면 업데이트
        - SPA
            
            : 사용자가 여러 페이지를 이동하더라고 최초에 서버에서 전송받은 하나의 HTML 이용해 컴포넌트만 교체해 렌더링
            
    - 장점
        - 최초 로딩은 느리지만 클라이언트 측에서 자바스크립트 사용해 동적으로 컴포넌트 렌더링해 지속적으로 볼 때 서비스 이용 경험 좋을 수 있음

- **최근 동향**
    - 초창기 웹 사이트(Web 1.0)
        - 사용자와 상호작용 최소화하고 서버에서 미리 만들어져 있는 정적인 파일 가져와 브라우저에 보여주는 형태
        
<br/>

## Back-End (Java)

### 1. `class`, `interface`

- **class**
    - 데이터와 기능을 포함하는 코드 묶음
    - 객체의 상태와 행동을 정의
    - 객체를 정의하는 틀, 설계도
    - 객체의 속성과 메서드의 집합을 담아놓은 것
    - 객체 구현하기 위한 청사진
    - 단일 상속을 통해 다른 클래스 기능 확장 가능
    - 객체 생성 가능
    - 코드의 재사용성을 높임
        - 상속을 통해 기능 확장 가능
    - 객체 구성
        - 필드 : 객체의 상태, 변수
        - 메소드 : 객체의 행동, 특정 작업 숭행하기 위한 명령문의 집합
    - 다중 상속을 지원하지 않음
        - 메소드의 출처 모호성 등 여러 문제 발생
- **추상 클래스**
    - 아직 완성되지 않은 클래스
    - 구성
        - 생성자, 필드, 일반 메서드, 추상 메서드
- **interface**
    - 클래스를 작성할 때 기본이 되는 뼈대
    - 클래스가 구현해야 하는 메서드의 명세를 정의
        - 구현을 통해 기능 제공
        - 클래스가 특정 기능 구현하도록 강제함
    - 클래스들이 구현해야 하는 동작을 지정하는데 사용되는 추상 자료형
    - 클래스 작성 시 기본 틀 제공 및 다른 클래스 사이 중간 매개 역할 담당
    - 다중 상속을 지원해 클래스는 다양한 동작을 수행 가능
    - 객체 생성 불가능
    - 다형성 제공
        - 구현을 통해 다형성 제공
    - 구성
        - 추상 메서드, 상수

<br/>

### 2. OOP 4가지 특징

- 객체 지향 프로그래밍(Object-Oriented Programming, OOP)
    - 여러 독립적인 부품들의 조합, 객체들의 유기적인 협력과 결합으로 파악하고자 하는 컴퓨터 프로그래밍의 패러다임
1. **추상화 (Abstraction)**
    - 사물의 공통적인 특징을 하나의 개념으로 다룸
    - 불필요한 세부 사항들은 제거하고 가장 본질적이고 공통적인 부분만 추출해 표현
    - 객체의 공통적인 속성과 기능을 추출해 정의하는 것
    - `추상 클래스`와 `인터페이스`

>    **자동차와 오토바이 → 이동 수단**
>    - 전진
>    - 후진

    
    
2. **상속 (Inheritance)**
    - 기존의 클래스를 재활용해 새로운 클래스를 작성하는 자바의 문법 요소
    - 상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능을 간편하게 사용할 수 있도록 함
    - 오버라이딩을 통해 메서드의 내용을 하위 클래스에서 재정의 가능
    - 장점
        - 코드의 재사용성 높이고 중복 줄임
    - `extends`

    
>    **자동차와 오토바이 → 이동 수단**
>    - 이동 수단
>        - 전진
>        - 후진
>    - 자동차
>        - 전진 (자동차가 앞으로 감)
>    - 오토바이
>        - 전진 (오토바이가 앞으로 감)
    
    
    
3. **다형성**
    - 어떤 객체의 속성이나 기능이 맥락에 따라 다른 역할을 수행할 수 있는 특성
    - 한 타입의 참조변수를 통해 여러 타입의 객체를 참조할 수 있도록 만든 것
        - 상위 클래스 타입의 참조변수로 하위 클래스의 객체 참조 가능
    - 장점
        - 코드의 유연성 증가
    - `메서드 오버라이딩`과 `인터페이스`
 
>    **사람은 `이동 수단`을 타고 이동합니다** 
>    - 이동 수단
>        - 자동차
>        - 오토바이

    
4. **캡슐화 (Encapsulation)**
    - 어떤 정보들을 외부로부터 숨김
    - 서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호하는 것
    - 캡슐화 이유
        - 데이터 보호 : 외부로부터 클래스에 정의된 속성과 기능들 보호
        - 데이터 은닉 : 내부의 동작을 감추고 외부에는 필요한 부분만 노출
    - 장점
        - 객체의 독립성 보장
        - 외부의 잘못된 사용으로부터 객체 보호
    - `접근 제한자`와 `컴포지션`

    
>    **자동차와 오토바이 → 이동 수단** 
>    - 자동차
>        - `private` 모델명
    
<br />

### 3. OOP 5원칙

1. **단일 책임 원칙(Single Responsibility Principle)**
    - 하나의 클래스는 하나의 책임만 가진다
        - 클래스의 변경 이유가 단 하나여야 한다
    - 장점
        - 클래스 변경 이유 명확해지고 시스템의 복잡성이 감소
        - 재사용성과 유지보수성 향상

    
>    **사용자 정보 관리** 
>    - 사용자 정보 저장 `class`
>    - 사용자 정보 표시 `class` 
>    ⇒ 각각의 클래스로 생성

    
2. **개방-폐쇄 원칙(Open-Closed Principle)**
    - 소프트웨어 구성요소(클래스, 모듈, 함수 등)는 확장에는 열려 있지만 변경에는 닫혀 있어야 한다
        - 기존의 코드를 변경하지 않고도 기능 추가 가능할 수 있어야 한다
    - 원칙 지키기위한 방법
        - 상속과 다형성이 확장에 열려있도록 만든다
        - 추상화는 변경에 닫혀있도록 만든다
    - 장점
        - 유연성과 확장성 향상
    
>    **결제 시스템 `interface`**
>    - 현금 `class`
>    - 카드 `class`
>    - … `class`

    
3. **리스코프 치환 원칙(Liskov Substitution Principle)**
    - 서브 타입은 언제나 그것의 베이스 타입으로 교체 가능
        - 서브 클래스는 슈퍼 클래스의 행위를 정확하게 모방,
        슈퍼 클래스의 인스턴스 대신 서브 클래스의 인스턴스 사용해도 시스템 정확성이 유지되어야 한다
        - 상위 클래스의 객체가 사용하는 메서드는 하위 클래스의 객체가 무엇인지 상관없이 하위 클래스의 객체도 사용할 수 있어야 한다
    - 장점
        - 다형성을 통한 유연한 설계 가능
    
>    **동물 ← 새, 물고기**
>    - 동물 `class`
>        - 이동()
>        - 새 `class`
>            - 이동() `@Override`
>        - 물고기 `class`
>            - 이동() `@Override`
    
4. **인터페이스 분리 원칙(Interface Segregation Principle)**
    - 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하면 안된다
        - 하나의 일반적인 인터페이스보다는 여러 개의 구체적인 인터페이스가 낫다
    - 장점
        - 클라이언트는 필요한 인터페이스만을 구현함으로써 불필요한 의존성을 줄일 수 있음
        - 시스템의 유연성 향상
    
>    **프린터 `interface`**
>    - 인쇄() `interface`
>    - 스캔() `interface`
>    - 팩스() `interface`
>    - ⇒ 인쇄만 따로 사용 가능
    
5. **의존 관계 역전 원칙(Dependency Inversion Principle)**
    - 구체화에 의존하지 말고 추상화에 의존한다
    - 고수준 모듈은 저수준 모듈에 의존해서는 안되며, 둘 다 추상화에 의존해야 한다
    - 추상화는 구체적인 것에 의존하면 안된다. 구체적인 것은 추상화에 의존해야 한다.

    
>    **토끼 `class`**
>    - 먹이 `vegetable`
>   
>    - vegetable
>        - apple
>        - carrot
    
<br />

### 4. 객체지향 / 절차지향

1. **객체 지향 프로그래밍(Object-Oriented Programming, OOP)**
    - 프로그램을 객체들의 집합으로 모델링해 객체 간의 상호작용을 통해 로직을 구성하는 프로그래밍 패러다임
    - 객체라는 기본 단위로 프로그램 구성
        - 객체는 데이터(속성)와 그 데이터를 처리하는 함수(메서드)를 하나로 묶은 것
    - 데이터와 함수를 하나의 객체로 묶어 관리
    - 기능을 가지고 있는 객체를 구현해, 객체들끼리 상호작용하도록 환경 조성
    - 객체를 생성해 객체끼리 관계를 맺음으로써 다수의 객체가 함께 수행될 수 있게 함
    - 특징
        - 캡슐화
        - 추상화
        - 상속
        - 다형성
    - 장점
        - 코드의 재사용성 높임 : 작성된 객체를 다른 곳에서도 사용 가능
        - 유지보수성 높임 : 객체 단위로 모듈화되어 특정 기능의 수정 필요 시 해당 객체만 수정하면 됨
    - 단점
        - 개발 속도 느림
        - 실행 속도 느림
        - 코딩 난이도 상승

    
>    **고객이 자판기에서 물건을 구매**
>    - 고객
>        - 자판기에 돈 넣음()
>    - 자판기
>        - 돈 받음()
>            - 받은 돈 검사()
>        - 제품 줌()
>        - 잔돈 줌()
    
2. **절차 지향 프로그래밍(Procedural Programming)**
    - 프로그램의 일련의 절차나 함수의 집합으로 보고, 이를 순차적으로 실행하여 문제를 해결하는 방식
    - 프로그램을 작은 단위의 함수로 나눠 이 함수들이 순차적으로 실행되도록 함
    - 각 함수는 특정 작업을 수행하며 프로그램의 전체 흐름은 이 함수들의 실행 순서에 따라 결정
    - 함수 호출을 통해 추상화와 재사용성을 이용하는것이 목표
    - 데이터와 함수를 별도로 다룸
    - 아무런 기능 없는 대상을 만들어 놓고 상황에 따라 컨트롤 통해 대상물 조정
    - 특징
        - Top-Down 방식 설계
        - 비교적 작은 규모의 작업을 수행하는 함수 생성
        - 인수와 반환값으로 명령 전달 및 수행
    - 장점
        - 구현이 간단
        - 실행 속도 빠름
    - 단점
        - 유지보수 어려움
        - 코드 순서 바뀌면 결과값 도출 어려움
        - 프로그램 분석 어려움
    
>    **고객이 자판기에서 물건을 구매**
>    - 고객이 돈을 넣었는지 확인()
>    - 받은 돈과 가격 비교()
>        - 받은 돈이 적으면 받은 돈 반환()
>    - 제품 및 잔돈 제공()
>    - 업데이트()
>        - 고객의 돈 -= 가격
>        - 자판기 돈 += 가격
>        - 고객 제품++
>        - 자판기 제품--