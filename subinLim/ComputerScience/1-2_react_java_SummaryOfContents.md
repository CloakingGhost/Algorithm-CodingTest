# Front-end

---

## **UI / UX**

- **UI** : 사용자에게 보여지는 화면
- **UX** : 사용자가 이용하며 느끼는 경험, 이벤트 처리

## DOM

### DOM, Virtual DOM

- **DOM (Document Object Model)**
    - 웹 페이지의 제목, 사진, 버튼과 같은 요소를 트리 구조로 표현한 것
        - 돔 조작을 통해 엘리먼트의 구조와 스타일 변경 가능
        - JavaScript를 사용해 DOM을 통해 다양한 요소 내용 변경 가능
        - `getElementById`, `querySelector` 같은 API를 통해 돔 엘리먼트를 수정
    - HTML 문서 구조를 객체로 표현
        - JS로 HTML 조작 가능
    - node.js로 DOM 조작 안됨
- **Virtual DOM**
    - 실제 DOM의 복사본, 메모리 안에 존재하는 자바스크립트 객체
        
        → 웹 페이지의 구조를 더 효과적으로 관리 가능
        
    - 실제 돔의 모든 엘리먼트와 속성 포함하지만, 브라우저의 DOM에 직접 접근 불가능
    - 컴포넌트 내 상태 관리하는 대상의 값이 변할 경우 변한 값만 업데이트해줌
        - 사용자에게 긍정적 경험 제공
    - 실제 DOM과 별개로 가상 DOM이 메모리에 저장되어 변경된 부분만 확인해 렌더링
    - 장점 : 비용 및 속도 측면 유리, 사용자 경험 향상, 서버 과부화 줄일 수 있음
    - **리액트의 가상 돔 활용 방식**

## **Callback Function**

- 함수의 인자로 전달되는 함수
- 호출 방법
    1. synchronous callbacks (동기식 콜백) : 중간에 비동기 작업 없이 외부 함수 호출 직후에 호출
    2. asynchronous callbacks (비동기식 콜백) : 비동기 작업이 완료된 후 나중에 호출

## Taliwind, Bootstrap

- **Taliwind**
    - 라이브러리
    - 유틸리티 클래스를 라이브러리로 모아둠
        
        `.m-1 { margin-top: 10px }`
        
    - 기능을 클래스화
    - CSS 이해도 높아야 함, HTML 지저분해짐
    - CSS 파일 관리 따로 안해도 됨, 커스텀 가능
- **Bootstrap**
    - 프레임워크
    - 완성된 컴포넌트 많이 제공
    - 유틸리티 클래스 제공
    - 기능을 컴포넌트화
    - 자주 사용되는 버튼이나 컴포넌트들을 미리 만들어져 있어 사용하기 간편함

## Interface

- **Interface : 사용하는 법**
    - A와 B가 소통하는 방법을 정한 것
- **API**
    - AP : 어플리케이션 프로그램, 서비스를 제공하는 무언가
    - API : 서비스를 제공하는 무언가끼리 소통하는 방법
- **Class Interface**
    - 클래스간 소통하는 방법

### API

- **하나의 프로그램에서 다른 프로그램으로 데이터를 주고받기 위한 방법**
    - 사용자가 어떤 데이터 원할지 요청 → API가 그에 맞는 데이터 제공
- 어플리케이션 간 통신 위한 지점
- API 작성 규칙
    - 요청 방식 : 요청할 내용, 어떤 정보 보낼 것인지
    - 요청 자료 : 요청할 자료의 종류 ⇒ 정확한 데이터의 송수신 가능
    - 파라미터 : 사용자 정보나 기타 부가적인 데이터

## Semantic Tag

- 의미와 기능을 가진 태그
- 시각 장애가 있는 사용자가 화면 판독기로 페이지 탐색 시 의미론적 마크업을 안내판으로 사용
- 검색 엔진은 의미론적 마크업을 페이지 검색 순위에 영향을 줌

## React

### **React**

- 웹 사이트나 애플리케이션을 만드는데 사용되는 `js 라이브러리`
- 컴포넌트아는 작은 부품으로 화면을 구성하는 방식을 사용해 작업을 효율적으로 만들어줌
- 사용자 인터페이스 만드는데 사용
- 등장 배경 : 클라이언트측의 경험이 좋아짐(기계 성능 좋아짐)
- 장점 : 부드러운 화면 전환으로 긍정적인 사용자 경험 제공
- 단점 : SEO 어려움, 정적인 컨텐츠가 많으면 로딩 시간 오래 걸림

### SSR & CSR

- **클라이언트 사이드 렌더링 (Client Side Rendering, CSR)**
    - 페이지 섹션에 들어와 빈껍데기가 브라우저로 담겨 옮 → JS 실행 → 백엔드의 데이터 요청 → json 데이터 → 브라우저에 렌더링
    - 처음 렌더링될 때 빈껍데기 : SEO 불리(취약) → 문제 해결 : Next.js
- **서버 사이드 렌더링 (Server Side Rendering, SSR)**
    - 하나의 완성된 페이지를 응답
    - 서버측에서 사용자 요청을 받으면 완성된 결과를 HTML로 보내줌
    - 로딩 속도 빠름
    - 장점 : SEO 유리
    - 단점 : 페이지 이동 시 마다 새로고침 발생

### SPA (Single Page Application)

- 단 하나의 HTML 페이지에서 작동
- 사용자가 특정 UI를 요구할 때 페이지를 새로 고치지 않고도 이를 실시간으로 변경할 수 있음
- 서버로부터 완전한 새로운 페이지 불러오지 않고 현재 페이지를 동적으로 다시 작성함으로써 사용자와 소통하는 웹 애플리케이션이나 웹 사이트
- index.html 한 페이지만 제공해 상태 관리 대상 값이 변경되었을 때, 변경된 값만 렌더링함
- 장점 : 매끄러운 사용자 경험 제공, 새로 고침 없이 부드러운 사용자 경험 제공
- 단점 : SEO에 좋지 않음, 처음 정적인 페이지를 모두 불러와 로딩 시간 오래 걸릴 수 있음
    1. 처음 data 없는 HTML, CSS, JS 제공 → 크롤러가 추출할 데이터가 없음 → 우선 순위 밀려짐 → SEO에 좋지 않음
    2. Next.js의 등장
        - 처음 SSR처럼 data와 함께 HTML, CSS, JS 제공 (이후에는 CSR로 진행) → 크롤러가 추출할 데이터 있음 → SEO에 좋음
    - 리액트 단점 커버 :  robots.txt 설정
        - 구글봇(구글 웹 크롤러 봇) 에게 수집 정보를 알려주는 **robots.txt** 파일을 설정해준다.(React 에서는 public 폴더 내)

### Hooks

- 함수형 컴포넌트에서 state 관리 위해 사용
- 화면에 보이는 변수의 변화를 적용해줄 수 있음

### 컴포넌트

- 재사용 가능한 UI 요소
- UI를 독립적이고 재사용 가능한 일부분으로 분할하고 각 부분을 개별적으로 다룰 수 있음
- props
    - 부모 컴포넌트 → 자식 컴포넌트로 데이터를 전달해주는 매개 변수
    - 재사용 가능한 UI 요소로 코드의 반복을 줄임

### **React effects 생명주기**

- **마운트** : 컴포넌트가 DOM에 처음 렌더링 될 때
- **업데이트** : 컴포넌트가 상호작용에 의한 응답으로 새로운 props나 state 수신할 때
- **마운트 해제** : 컴포넌트에 의해 생성된 DOM이 삭제될 때

## Asynchronous

### 비동기

- 사용자 요청에 대한 응답을 기다리지 않고 다른 일 수행 가능
- **비동기 통신**
    - 통신을 비동기적으로(응답을 기다리지 않고) 처리
    - HTTP 통신 : Header와 Body로 구성 (Header에 요청 위한 메타 데이터 저장)

### 이벤트 루프

- 웹 API
- 웹 api에서 동작 후 종료 되면 → 콜백 큐로 이동 → 콜 스택 내부 진행 모두 종료되면 → 콜 스택으로 이동 → 결과 보여줌
    - 콜백 큐
        - micro task queue :  프로미스 객체가 들어감
        - task queue
- Promise
    - 비동기 작업에 대해 성공과 실패에 대해 처리하는 문법
    - 목적 : 콜백 지옥 방지

### Fetch & Axios

- 비동기 통신을 위한 기능
- **fetch api 와 axios api 비교**
    - fetch : 웹 api가 가지고 있음, 기본 제공
        - fetch api에서는 직접 json으로 한 번 더 변환해주어야 함
    - axios : 라이브러리, 인스턴스를 생성해 baseUrl 지정 및 헤더에 필요한 데이터 저장 가능
        
        → 재사용 가능, 반복 줄임
        
        - 구형 브라우저 포함한 대부분의 환경에서 잘 동작

## URL

### HTTP

- 서버와 클라이언트 간 데이터 주고 받을 때 소통을 약속한 것
- 약속은 URL을 통해서 진행함
- fetch/axios 통해 URL 요청
    - 요청을 통해 데이터 응답 받기 위해 URL 사용

### RESTful API

- URL(자원의 경로)과 메서드(어떤 요청)를 보고 리소스, 어떤 데이터 및 역할인지 특정할 수 있으면 RESTful 함

## Back-End

---

## JVM

### JVM 사용 이유

- 자바를 돌려주는 머신
- 운영체제 마다 기계어가 다른데 현재 실행되는 OS 환경에 맞는 기계어로 변환해줌
    
    → 이식성이 좋음
    

### JVM 메모리 관리

- **구성**
    - Heap → 가비지 컬렉터가 관리
        - 참조 객체
        - 변수
    - Stack
        - 지역 변수
        - 함수 실행 순서
    - Method
        - 상수
        - static 메서드
        - 객체 필드

### GC (Garbage Collector)

- **가비지 컬렉터** : 메모리 관리
    - 참조하지 않는(연결이 끊어진) 참조 객체 → 사용X → 가비지 컬렉터가 지움
- 단점 : 컨트롤할 수 없는 영역

### JRE

- JVM + 라이브러리
- 자바 돌아가는 환경

### JDK

- Java 애플리케이션의 개발을 위한 툴 세트
- JVM + 라이브러리 + 컴파일러 + 테스트 코드 + AOP
- AOP : 관점 지향 프로그래밍
- Java 애플리케이션 개발에 사용할 수 있는 소프트웨어 도구 모음

## OOP (Object Oriented Programming)

### OOP의 4가지 특징

1. **다형성**
    - 동적 바인딩
    - 상위 타입으로 하위 타입을 사용 가능
    - 코드의 유연성 증가
    - Java : 오버라이딩, 인터페이스
2. **상속**
    - 부모 클래스의 공통 기능 및 특징을 상속받은 자식 클래스에서 접근 가능 (기능 확장)
    - 중복 줄임, 코드 재사용성 향상
    - Java : extends
3. **캡슐화**
    - 외부로부터 데이터 은닉, 보호
    - 객체의 독립성 보장, 외부의 잘못된 사용으로부터 객체 보호
    - Java : 접근제어자, 컴포지션
4. **추상화**
    - 구체적인 내부 로직 몰라도 외부에서 어떤 기능인지 알면 사용 가능
    - 대상이나 개념에 대해 공통적인 특징 추출해 구체화 가능
    - Java : 추상 클래스, 인터페이스

### OOP SOLID 원칙

- **단일 책임 원칙(Single Responsibility Principle)**
    - 하나의 클래스는 하나의 책임만 가진다
    - 클래스의 변경 이유는 단 하나 !
    - 장점
        - 클래스 변경 이유 명확
        - 시스템 복잡성 감소
        - 재사용성, 유지보수성 향상
- **개방-폐쇄 원칙(Open-Closed Principle)**
    - 소프트웨어 구성요소는 확장에는 열려있지만 변경에는 닫혀 있어야 한다
        - 기존의 코드를 변경하지 않고도 기능 추가 가능할 수 있어야 한다
    - 장점
        - 유연성, 확장성 향상
    - 원칙 지키기 위한 방법
        - 상속, 다형성이 확장에는 OPEN, 추상화는 변경에 CLOSE
- **리스코프 치환 원칙(Liskov Substitution Principle)**
    - 서브 타입은 언제나 그것의 베이스 타입으로 교체 가능하다
        - 상위 클래스의 객체가 사용하는 메서드는 하위 클래스의 객체가 무엇인지 상관없이 하위 클래스의 객체도 사용할 수 있어야 한다
    - 장점
        - 다형성을 통한 유연한 설계 가능
- **인터페이스 분리 원칙(Interface Segregation Principle)**
    - 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하면 안된다
        - 하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다
    - 장점
        - 클라이언트는 필요한 인터페이스만을 구현해 불필요한 의존성 줄임
        - 시스템의 유연성 향상
- **의존 관계 역전 원칙(Dependency Inversion Principle)**
    - 구체화에 의존하지 말고 추상화에 의존한다
        - 고수준 모듈은 저수준 모듈에 의존해서는 안되며, 둘 다 추상화에 의존해야 한다

### 접근 제어자 (Access Modifier)

- public : 전체 공개
- protected : 같은 패키지 및 다른 패키지일 경우 자식 클래스 접근 가능
- private : 같은 클래스 내 접근 가능
- default : 같은 패키지 내 접근 가능

## 객체 지향과 절차 지향

### 객체 지향

- 작은 기능을 담당하는 객체들을 여러 개 만들고 서로 상호작용해 큰 문제를 해결

### 절차 지향

- 프로그램을 작은 단위의 함수로 나눠 이 함수들이 순차적으로 실행되도록 함

## class & Interface

### class

- 대상의 개념이 개발에 필요한(문제 해결 위한) 기능과 특징을 추출해낸 설계도
- 객체의 상태와 기능을 묶어놓은 설계도

### 인터페이스

- 기능을 구현하도록 강제성을 띄는 추상 메서드를 가진 클래스

### 오버라이딩, 오버로딩

- 오버라이딩
    - 부모 클래스의 메서드를 자식 클래스에서 재정의함(구체화)
- 오버로딩
    - 매개변수나 매개변수의 타입이 다르지만 이름은 같은 메서드