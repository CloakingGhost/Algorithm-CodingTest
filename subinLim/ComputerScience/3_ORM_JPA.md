## ORM (Object-Relational Mapping)

- 자바의 객체와 관계형 데이터베이스를 매핑하는 프로그래밍 기법
- SQL 쿼리 없이 데이터를 데이터베이스에 저장 및 관리 가능
- ex. JPA, Hibernate

- **주요 기능**
    - 객체와 테이블간 매핑
    - 데이터 쿼리 및 조작
    - 트랜잭션 관리

- **장점**
    - 개발자가 객체 지향 언어로 데이터베이스의 데이터를 쉽게 조작

      (개발자가 객체 지향 프로그래밍에 집중)

      → 개발 과정 단순화, 개발 시간 단축, 코드의 가독성 높임

    - 데이터베이스 설계 변경 시 유연한 대응 가능

      → 애플리케이션 확정성, 유지보수성 향상

    - 데이터베이스 독립성 제공

      → 애플리케이션 코드 변경 없이 다른 유형의 데이터베이스로 쉽게 전환 가능, 데이터베이스와 결합도 낮춤

    - 데이터베이스 설계와 비즈니스 로직 사이 간극 줄여줌

- **단점**
    - 프로젝트의 복잡성이 커질수록 사용 난이도 올라감
    - 복잡하고 무거운 쿼리는 ORM으로 해결 불가능한 경우가 있음

## JPA

### JPA

- Java Persistence API
- 실제 구현체가 아닌 인터페이스의 모음
- 자바에서 데이터베이스와 객체의 관계를 매핑하는 표준 규약

### 영속성, Dirty Checking

- **영속성**
    - 데이터를 생성한 프로그램이 종료되어도 사라지지 않는 데이터의 특성

- **영속성 컨텍스트 (Persistence Context)**
    - 엔티티를 영구 저장하는 환경
    - `EntityManager` 통해 엔티티 관리

    - **특징**
        1. **1차 캐시**
            - 데이터베이스로부터 읽어온 엔티티를 메모리에 캐싱해 같은 트랜잭션 내에서 데이터베이스 접근 없이 데이터 재사용 가능
        2. **동일성 보장**
            - 같은 엔티티 조회 시 항상 같은 인스턴스 반환
        3. **쓰기 지연**
            - 여러 변경 사항을 모아 한 번에 데이터베이스에 반영해 네트워크 비용 줄이고 성능 향상
        4. **변경 감지 (Dirty Checking)**
            - 엔티티의 변경 사항을 자동으로 감지해 업데이트 쿼리 생성해 개발자가 수동으로 변경 사항을 관리할 필요 없게 함
            - 변경 감지를 통해 setter 메서드 사용 시 영속성 컨텍스트의 변경 사항이 자동으로 반영됨
        5. **지연 로딩**
            - 연관된 엔티티를 실제 사용하는 시점에 로딩

    - **장점**
        - 데이터베이스의 연산 성능 향상
        - 쉬운 데이터 관리
        - 객체 생명주기 관리로 데이터 일관성 유지
        - 데이터베이스의 접근을 최소화

### 연관관계(다대다 처리)

- **One-to-Many**는한 엔티티가 여러 엔티티와 연결되는 관계이다.
    - 단방향에서 부모 엔티티가 자식 엔티티를 직접 참조하지 않아 자식 엔티티가 부모 엔티티의 외래 키를 저장할 수 없어 관리 위해 별도 연결 테이블이 필요한데, 이는 메모리 사용 증가와 성능 저하를 일으킬 수 있다.
    - `@JoinCloumn` 추가 시 자식 테이블의 외래키를 부모 엔티티가 직접 제어할 수 있어 쿼리 수 줄어들지만 여전히 업데이트문 발생해 성능 저하 일어날 수 있다.
    - `@JoinCloumn` : 엔티티 사이 외래키 관계 정의

    - 양방향에서 부모 측에 전이 타입을 설정하고, 자식 측에 many-to-one 전이 타입을 설정하지 않아야 한다.
    - 전이 : 부모 엔티티의 상태가 자식 엔티티로 전파되는 것
  
  <br/>

- **Many-to-Many**는여러 엔티티가 여러 엔티티와 연결되는 관계이다.
    - 양방향에서 부모 역할을 하는 양측이 있으며 연결 테이블을 통해 두 개의 외래 키를 관리한다.
    - 리스트 처리 방식에서 삭제 시 여러 쿼리 발생하지만 Set 사용 시 하나의 DELETE문 만으로 처리 가능해 성능 개선할 수 있다.
    - 지연 로딩 사용이 필수적으로, 즉시 로딩 사용 시 성능 저하롸 비효율적인 데이터 로딩을 초래할 수 있다.

- 지연 로딩 : 필요한 데이터만 요청할 때 불러오는 방식
- 즉시 로딩 : 필요한 모든 데이터를 한 번에 요청하는 방식

  <br/>


- **One-to-One**은 한 엔티티가 다른 엔티티와 정확히 1 : 1로 연결되는 관계이다.
    - 단방향은 부모 엔티티가 자식 엔티티의 식별자를 알 수 없어 추가 쿼리 발생해 성능 저하가 일어날 수 있다.
    - 양방향은 부모 엔티티가 조회될 때 자식 엔티티도 함께 로딩되어 추가적인 리소스 낭비와 성능 저하를 초래할 수 있다.

    - 자식 측에 `@Mapsld` 추가해 자식 테이블이 부모 테이블과 기본키 공유하면 연결 관계 최적화로 성능 개선 및 메모리 사용량을 줄일 수 있다.
    - `@Mapsld` : 자식 엔티티가 부모 엔티티의 기본키 공유하도록 설정

### N + 1 문제 해결

- 연관 관계가 설정된 엔티티 조회할 때, 예상치 못한 많은 수의 쿼리가 발생하는 현상으로, 로딩 전략은 예상 데이터 접근 패턴과 실제 접근 패턴이 달라 비효율적인 접근을 초래한다.
- 지연 로딩은 연관된 엔티티에 접근하는 시점에 추가 쿼리가 발생하고, 즉시 로딩은 원본 엔티티 조회 시 연관된 엔티티도 함께 조회하려고 해 많은 쿼리가 발생한다.
- 이를 해결하기 위해 첫번째로, 패치 조인은 쿼리 작성 시 연관된 엔티티를 함께 조회하도록 명시적으로 지정해, 원본 데이터와 연관된 엔티티를 한 번의 쿼리를 함께 조회할 수 있다.
- 두번째로, 엔티티 그래프는 엔티티 조회시 연관된 엔티티를 어떻게 로딩할지 미리 정의해 패치 조인보다 더 선언적이고 유연한 방식으로 연관 엔티티의 로딩 전략을 제어할 수 있다.

### Spring Data JPA

- JPA를 더 편리하게 사용할 수 있도록 스프링에서 제공하는 프로젝트
- Repository 인터페이스를 통한 추상화된 데이터 접근 계층을 제공
    - `JpaRepository` 인터페이스를 상속 받아 제네릭에 `<엔티티 이름, 엔티티 기본키의 타입>` 입력 시 기본 CRUD 메서드 사용 가능
- **장점**
    - 인터페이스만으로 구현체 만들어줌
    - 메소드 이름만으로 쿼리 생성 가능
    - 페이징, 정렬 등 데이터 접근 코드를 자동으로 제공
    - 반복적인 CRUD 작업을 위한 공통 인터페이스 제공
    - 명시적인 설정 없이도 JPA를 스프링과 통합해 사용 가능
- **단점**
    - JPA와 마찬가지로 복잡한 쿼리 처리
    - 메서드 이름이 길어질 수 있음
    - JPA/Hibernate를 이해하지 못할 경우 문제 해결이 어려울 수 있음

### Hibernate

- JPA의 대표적이고 널리 사용되는 구현체, ORM 기능을 사용할 수 있게 해주는 도구
- JPA 인터페이스를 구현한 구현체, 자바용 ORM 프레임워크
- JPA를 구현한 라이브러리
- 데이터를 보다 쉽게 다룰 수 있도록 도와줌
- **특징**
    - JPA 표준 기능 외 추가 기능 제공
        - 다양한 매핑 어노테이션
        - 고급 캐싱 전략
        - 네이티브 SQL 지원