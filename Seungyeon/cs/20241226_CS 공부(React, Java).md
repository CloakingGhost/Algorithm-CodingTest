
- **백엔드, 프론트엔드 CS 공부 및 답변 준비**
    - **Front-End**
        - React
		    - 페이스북에서 개발한 자바스크립트 라이브러리로 사용자 인터페이스(UI)를 구현하기 위해 사용한다.

            - component
	            - 재사용 가능한 UI요소를 의미한다. 코드를 하나의 부품처럼 사용하는 것을 의미한다. 조금 더 구체적으로는 렌더링 가능한 요소를 반환하는 함수를 구성하는 것을 의미한다.

            - SPA
	            - Single Page Application, 필요한 데이터만 비동기로 받아와서 동적으로 현재 화면에 다시 렌더링 하는 방식을 의미한다.
	            - 과거 웹사이트는 현재처럼 유저 인터랙션이 많은 페이지가 없었고, 페이지의 용량도 가벼웠다. 그러나 현재에 들어서면서 실시간으로 많은 유저의 인터렉션이 일어나는 페이스북, 인스타그램, 유튜브 등의 서비스들이 생겨나면서 화면 깜박임이 없으면서 부드럽게 잘 동작하는 웹사이트의 개발이 필요하게 되었다.
	            - 이러한 문제를 해결하기 위해 많은 프레임워크들이 생겨났지만, 리액트가 가장 성공적으로 자리를 잡게 되었다. 리액트는 CSR 방식을 채택한 것이며, Single Page Application의 구축을 가능하게 해준다. 초반에 표시되는 index.html 파일 외에 html 문서는 없으며, index.html 파일의 내용을 자바스크립트를 이용해 재 렌더링 해주는 방식으로 페이지를 구성한다. 그래서 페이지 별로 파일ㅇ르 구성하지 않고 표시해주어야 할 내용을 각각의 컴포넌트 형식으로 구성한다.
            
            - Virtual DOM
	            - DOM이란, 'Doucument Object Model'의 약자로 주로 html 문서 내에 요소를 말한다. html, css, javascript로 만들었던 웹사이트에서는 querySelector나 getElenentbyID 같은 것들로 직접 DOM 요소를 찾아 직접 조작한다. 이렇게 직접 요소를 조작하는 방식은  페이지 내에 정보가 변할 때마다 다시 페이지를 로드해야 해서 페이지 용량이 크면 클수록 느려지는 단점이 있다. 그러나 CSR 방식으로 한번에 모든 정보를 받고 Virtual DOM을 이용해 페이지 내에 변한 부분만을 감지해서 그 부분만 변경해주게 되면 훨씬 부담을 줄일 수 있다.
	            - 여기서 Virtual DOM이 동작하는 방식은 이러하다. 유저 인터렉션이 일어나면 Virtual DOM에 의해 구성된 DOM 트리는 이전 페이지와 바뀐 부분들을 감지한다. 그래서 변화된 부분만 재 렌더링을 해준다. 그럼 변화를 감지하고 렌더링을 다시 하는 일이 뭔가 더 오래 걸리는 일이 아닌가 싶지만, 렌더링이라는 게 훨씬 더 부담이 많이 가는 동작이고 Virtual DOM 이 감지하는 일은 실제 렌더링을 하지 않기 때문에 빠르다.
            
            - JSX
	            - 리액트에서는 JSX 문법을 사용해서 요소를 만들기 때문에(필수는 아님, 주로 그렇게 사용함) html 문법에 익숙한 사용자에게는 빠르게 친숙해 질 수 있다는 장점이 있다. 사실, JSX는 html과 비슷하게 생겼지만, 자바스크립트의 확장 문법이다. 고로 html이 아니기 때문에 코드가 번들링 되는 과정에서 BABEL이 html 문서로 변환시킨다.
	            - 이러한 JSX 문법 덕분에 컴포넌트 별로 구성이 가능하다. 컴포넌트 별로 문서를 만들게 되면 재사용성이 좋아진다.
            
            - SSR: Server Side Rendering, 서버 측에 페이지를 렌더링 한다는 의미
	            - 인덱스 페이지에 표시되어야할 html 파일을 먼저 브라우저가 다운 받고 javascript파일을 다운 받는 동안에 이미 html 파일의 렌더링을 시작하기 때문에 웹페이지 표시가 빠르다. 그러나 컴퓨터의 속도가 느리다면 처음에 javascript가 다 다운이 받아지지 않아서 기능이 동작하지 않을 수도 있다. 그다음 사용자가 네비게이션의 링크를 클릭하여 페이지를 이동했을 때 해당 페이지의 html파일을 다운 받고 있어서 javascript 파일을 다운 받는 일련의 과정이 반복된다.
	            - 렌더링이 빠른 장점이 있지만 페이지를 이동할 때마다 화면 깜박임(화면이 로드될 때마다 화면이 백지로 변하고 다시 화면이 출력되는 과정)이 있다. 웹페이지의 용량이 가벼울 경우에는 문제가 없으나 무거워질 경우에는 화면 깜박임이 길어져 사용자 경험이 나빠질 수 있다.
	        
            - CSR: Client Side Rendering,  클라이언트 측에 페이지를 렌더링 한다는 의미
	            - 맨 처음 url 요청에 웹문서가 가지고 있는 모든 정보, 링크페이지까지도 한번에 다 받아온다.
	            - 초기 화면 로드가 느리다. 그러나 일단 로드가 되고 나면 사이트 내에서 돌아다닐 때 로드되는 과정이 없어지므로 사용성이 좋아진다.
	            - 페이스북과 같은 대형 플랫폼에서 화면에 많은 사진과 정보가 있음에도 페이지를 이동할 때 화면 깜박임이 없는 이유는 바로 이 때문이다. 그래서 보통 로드가 될 때 'Loading'임을 표시해주는 화면이 먼저 표시되도록 만든다.
	            - 그렇지만 CSR이 사용성이 좋아서 무조건 CSR방식을 채택해야 하는 것은 아니다. CSR 방식은 보통 링크 이동을 할 때 자바스크립트를 이용해 동적으로 화면을 바꿔주므로, index.html 문서가 가지고 있는 정보가 적어서 검색 엔진들이 웹사이트를 분석해서 내용들을 파악하고 검색 시 뿌려주어야 할 때 제대로 걸러지지 못하게 된다. 이를 SEO(검색엔진최적화)가 나쁘다고 말한다. 
			
    - **Back-End**
        - Java
            - class : 비슷한 속성과 기능을 모아 새로운 타입을 정의할 수 있는 설계도
            
            - interface : 일종의 `명세`로써 각 구현 클래스들이 어떤 기능을 필수로 구현해야 하는지를 정의한 추상 클래스를 말한다.
	            - 인터페이스는 Java에서만 사용하는 용어는 아니다. 원래 인터페이스는 `"서로 다른 대상끼리 맞닿은 면"`을 의미한다. 그래서 `GUI`나 `CLI`와 같은 것들에서 `I`가 모두 인터페이스를 의미하는데, 이들은 컴퓨터와 사람이라는 서로 다른 대상이 맞닿을 수 있는 면을 제공하고 정해진 규칙을 통해 서로 소통할 수 있게 한다.
	            - Java의 인터페이스에는 각 클래스들이 어떤 메서드를 구현해야 하는지에 대한 선언부만 작성된다. 메서드를 사용하는 외부 대상은 명세에 따라 호출만 할 뿐, 실제 세부 구현은 알지 못한다. 세부 구현은 각 구현 클래스에서만 알고 있다. 따라서, 인터페이스도 추상 클래스와 마찬가지로 추상화와 다형성이라는 특징을 통해 유연한 프로그래밍을 가능하게 하고자 사용된다.
            
            - OOP 4가지 특징
		        1. 캡슐화(Encapsulation)
	            - 객체의 내부 상태를 외부에서 접근하지 못하도록하여 데이터를 보호하는 특성을 말한다.
	            - 이를 통해 객체 내부의 데이터가 오염될 가능성이 줄어들고, 객체 내부의 수정이 외부로 전파되지 않는다.
	            - Java에서는 `접근 제한자`와 `컴포지션`을 통해 캡슐화를 만족시킨다.
				
				2.상속(Inheritance)
				- 기존 클래스의 속성과 메서드를 물려받아 새로운 클래스를 생성하는 것을 말한다.
				- 이를 통해 코드의 재사용성을 높이고 공통의 속성ㅇ르 부모 클래스에 정의하여 코드의 일관성을 유지한다.
				- Java에서는 `extends`키워드를 통해 상속을 만족시킨다.
				
				3.추상화(Abstraction)
				- 객체의 복잡한 세부 사항은 숨기고, 외부에 필요한 핵심 기능만 노출하는 것을 말한다.
				- 캡슐화와 비슷하다고 느낄 수 있지만 캡슐화는 정보 은닉과 보호에 초점이 맞춰진 개념이고, 추상화는 세부 구현을 자식 클래스에게 위힘하는 것에 초점이 맞춰진 개념이다.
				- 이를 통해 다형성과 연계하여 코드의 핵심 기능에만 집중하게 만들어 전반적인 유지보수성을 높인다.
				- Java에서는 `추상 클래스`와 `인터페이스`를 통해 추상화를 만족시킨다.
				
				4.다형성(Polymorphism)
				- 동일한 부모 클래스나 인터페이스를 기반으로, 서로 다른 세부 구현이 실행되도록 하는 성질을 말한다.
				- 하나의 상위 타입을 통해 여러 개의 하위 타입 구현체들을 사용할 수 있다.
				- 이를 통해 전체적으로 유연한 코드 설계가 가능해진다.
				- Java에서는 `메서드 오버라이딩`과 `인터페이스`를 통해 다형성을 만족시킨다.
			
            - OOP 5원칙
	             SOLID는 객체 지향 프로그래밍의 5가지 핵심 설계 원칙이다.
                1. 단일 책임 원칙(**S**ingle Responsibility Principle)
		        - 한 클래스는 하나의 책임만 가져야한다.
		        - 예시: 사용자 클래스가 있다면, 사용자 정보 관리만 담당해야하며 로깅이나 데이터 검증 같은 다른 책임은 별도 클래스로 분리해야한다.
		        
                2. 개방-폐쇄 원칙(**O**pen-Closed Principle)
		        - 확장에는 열려있고, 수정에는 닫혀있어야 한다.
		        - 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있어야한다.
		        - 예시: 도형의 면적을 계산하는 시스템에서 새로운 도형을 추가할 때 기존 코드를 수정하지 않고 새로운 클래스만 추가한다.
				    
                3. 리스코프 치환 원칙(**L**iskov Substitution Principle)
                - 자식 클래스는 부모 클래스의 자리에 항상 교체될 수 있어야 한다.
                - 상속 관계에서 자식 클래스는 부모 클래스의 계약을 반드시 지켜야한다.
                - 예시:Bird 클래스를 상속받는 Penguin 클래스에서 fly() 메서드를 구현할 때 발생할 수있는 문제
                
                4. 인터페이스 분리 원칙(**I**nterface Segregation Principle)
                - 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다.
                - 큰 인터페이스를 여러 개의 작은 인터페이스로 분리해야 한다.
                - 예시: 프린터 인터페이스를 출력, 스캔, 팩스 등 각각의 기능별로 분리한다.
                
                5. 의존 관계 역전 원칙(**D**ependency Inversion Principle)
                - 고수준 모듈은 저수준 모듈에 의존하지 않아야 한다. 둘 다 추상화에 의존해야 한다.
                - 추상화는 세부 사항에 의존하지 않아야 한다.
                - 예시: 데이터베이스 접근 시 구체적인 데이터베이스 클래스가 아닌 인터페이스에 의존하도록 설계한다.
                
            - 객체지향(Object-Oriented Programming,OOP)
            - 프로그래밍에서 필요한 데이터를 추상화 시켜 `상태와 행위를 가진 객체`로 만들고, 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.
            
            - 객체란?
            - 프로그램에서 사용되는 데이터 또는 식별자에 의해 참조되는 공간을 의미하며 값을 저장할 `변수`와 작업을 수행할 `메소드`를 서로 연관된 것들끼리 묶어서 만든 것을 객체라고 할 수 있다.
            - 객체지향 프로그래밍을 레고에 빗대 표현 할 수 있는데, `객체`가 레고의 조각이 될 것이고 레고의 조각을 조립해서 무언가를 만드는 방식이 객체지향 프로그래밍이라고 할 수 있다.
	        - 객체는 또한 레고 조각과도 비슷하게 여러군데에서 재사용 할 수 있는데 이는 `부품화`와 `재사용성`이라는 객체 지향 프로그래밍의 특징을 보여주기도 한다.
            
            - 장점
            - 클래스 단위로 모듈화시켜서 개발하기 때문에 업무 분담이 편리하고 대규모 소프트웨어 개발에 적합하다.
            - 클래스를 재사용하거나 상속을 통해 확장함으로써 코드 재사용이 용이하다.
            - 클래스 단위로 수정이 가능하기 때문에 유지보수가 편리하다.
            
            - 단점
            - 절차 지향보다 상대적으로 느린 처리속도
            - 객체의 수가 많아짐에 따라 용량이 커질 수 있다.
            - 설계에 많은 시간 소요
            
            - 절차지향(Procedural Programming)
            - 물이 위에서 아래로 흐르는 것처럼 순차적인 처리가 중요시되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법
            
            - 장점
            - 컴퓨터의 처리구조와 유사해 실행 속도가 빠름
            
            - 단점
            - 어려운 유지보수와 디버깅
            - 실행 순서가 정해져 있으므로 코드의 순서가 바뀌면 동일한 결과를 보장하기 어려움